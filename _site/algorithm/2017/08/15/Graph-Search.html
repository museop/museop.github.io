<!DOCTYPE html>
<html lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      그래프 탐색(Graph Search) &middot; Pleasure of Learning
    
  </title>
  <!-- FONT -->
  <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css" rel="stylesheet" />

  <!-- CSS -->
  <link rel="stylesheet" href="/public/css/poole.css">
  <link rel="stylesheet" href="/public/css/syntax.css">
  <link rel="stylesheet" href="/public/css/lanyon.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Serif:400,400italic,700%7CPT+Sans:400">
  <link rel="stylesheet" href="/public/css/mycss.css">
  
  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/public/apple-touch-icon-precomposed.png">
  <link rel="shortcut icon" href="/public/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">
  
  <!-- MathJax -->
  
	<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
  
</head>


  <body>
  
    <!-- Target for toggling the sidebar `.sidebar-checkbox` is for regular
     styles, `#sidebar-checkbox` for behavior. -->
<input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox">

<!-- Toggleable sidebar -->
<div class="sidebar" id="sidebar">
  <div class="sidebar-item">
    <p>This Blog is using my study.</p>
  </div>

  <nav class="sidebar-nav">
    <a class="sidebar-nav-item" href="/">Home</a>

    

    
    
      
        
      
    
      
        
      
    
      
        
          <a class="sidebar-nav-item" href="/about.html">About</a>
        
      
    
      
        
          <a class="sidebar-nav-item" href="/archive.html">Archive</a>
        
      
    
      
    
      
        
          <a class="sidebar-nav-item" href="/category.html">Category</a>
        
      
    
      
        
      
    
      
        
      
    
      
        
          <a class="sidebar-nav-item" href="/tags.html">Tags</a>
        
      
    
<!--
    <a class="sidebar-nav-item" href="/archive/v1.0.1.zip">Download</a>
    <a class="sidebar-nav-item" href="">GitHub project</a>
    <span class="sidebar-nav-item">Currently v1.0.1</span> -->
  </nav>

  <div class="sidebar-item">
    <p>
      &copy; 2018. All rights reserved.
    </p>
  </div>
</div>


    <!-- Wrap is the content to shift when toggling the sidebar. We wrap the
         content to avoid any CSS collisions with our real content. -->
    <div class="wrap">
      <div class="masthead">
        <div class="container">
          <h3 class="masthead-title">
            <a href="/" title="Home">Pleasure of Learning</a>
            <small></small>
          </h3>
        </div>
      </div>

      <div class="container content">
        <div class="post">
  <h1 class="post-title">그래프 탐색(Graph Search)</h1>
  <span class="post-date"><time>15 Aug 2017</time></span>
  <div class="post-tags">
      
        <a class="post-tags-item" href="http://localhost:4000/tags#graph">
          <span>graph</span>
        </a>
      
        <a class="post-tags-item" href="http://localhost:4000/tags#graph search">
          <span>graph search</span>
        </a>
      
  </div>

  <ul id="markdown-toc">
  <li><a href="#깊이-우선-탐색depth-first-search-dfs" id="markdown-toc-깊이-우선-탐색depth-first-search-dfs">깊이 우선 탐색(Depth First Search, DFS)</a></li>
  <li><a href="#너비-우선-탐색breadth-first-search-bfs" id="markdown-toc-너비-우선-탐색breadth-first-search-bfs">너비 우선 탐색(Breadth First Search, BFS)</a></li>
  <li><a href="#컴포넌트components-찾기" id="markdown-toc-컴포넌트components-찾기">컴포넌트(Components) 찾기</a></li>
  <li><a href="#위상-정렬topological-sort" id="markdown-toc-위상-정렬topological-sort">위상 정렬(Topological Sort)</a></li>
  <li><a href="#이분-그래프-검사하기bipartite-graph-checking" id="markdown-toc-이분-그래프-검사하기bipartite-graph-checking">이분 그래프 검사하기(Bipartite Graph Checking)</a></li>
  <li><a href="#사이클-찾기cycle-detection" id="markdown-toc-사이클-찾기cycle-detection">사이클 찾기(Cycle Detection)</a></li>
  <li><a href="#오일러-서킷eulerian-circuit-찾기" id="markdown-toc-오일러-서킷eulerian-circuit-찾기">오일러 서킷(Eulerian Circuit) 찾기</a></li>
  <li><a href="#dfs-스패닝-트리dfs-spanning-tree" id="markdown-toc-dfs-스패닝-트리dfs-spanning-tree">DFS 스패닝 트리(DFS Spanning Tree)</a></li>
  <li><a href="#단절점articulation-points-cut-vertices-찾기" id="markdown-toc-단절점articulation-points-cut-vertices-찾기">단절점(Articulation Points, Cut Vertices) 찾기</a></li>
  <li><a href="#단절선bridges-찾기" id="markdown-toc-단절선bridges-찾기">단절선(Bridges) 찾기</a></li>
  <li><a href="#강결합-컴포넌트strongly-connected-components-찾기" id="markdown-toc-강결합-컴포넌트strongly-connected-components-찾기">강결합 컴포넌트(Strongly Connected Components) 찾기</a>    <ul>
      <li><a href="#타잔-알고리즘targan-algorithm" id="markdown-toc-타잔-알고리즘targan-algorithm">타잔 알고리즘(Targan algorithm)</a></li>
      <li><a href="#코사라주-알고리즘-kosarajus-algorithm" id="markdown-toc-코사라주-알고리즘-kosarajus-algorithm">코사라주 알고리즘 (Kosaraju’s algorithm)</a></li>
      <li><a href="#2-sat-문제" id="markdown-toc-2-sat-문제">2-SAT 문제</a></li>
    </ul>
  </li>
  <li><a href="#연습-문제" id="markdown-toc-연습-문제">연습 문제</a></li>
  <li><a href="#참고-자료" id="markdown-toc-참고-자료">참고 자료</a></li>
</ul>
<h2 id="깊이-우선-탐색depth-first-search-dfs">깊이 우선 탐색(Depth First Search, DFS)</h2>

<p>그래프의 모든 정점을 탐색하는 방법중 하나인 깊이 우선 탐색(이하 DFS)은 시작 정점부터 방문하여 현재 방문중인 정점 u에서 아직 방문하지 않은 정점 v로 향하는 간선이 존재한다면  그 간선을 타고 정점 v를 방문한다. 이 과정에서 더 이상 갈 곳이 없는 정점에 도달하면, 이 정점 이전에 마지막으로 방문했던 정점으로 돌아가 이와 같은 과정을 반복하는 탐색 알고리즘이다. 시간복잡도는 <script type="math/tex">O(V+E)</script>이다.</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">adj</span><span class="p">[</span><span class="n">MAX_V</span><span class="p">];</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">visited</span><span class="p">[</span><span class="n">MAX_V</span><span class="p">];</span> <span class="c1">// initially set all false
</span>
<span class="kt">void</span> <span class="nf">dfs</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">visited</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"visit vertex "</span> <span class="o">&lt;&lt;</span> <span class="n">u</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">v</span><span class="o">:</span> <span class="n">adj</span><span class="p">[</span><span class="n">u</span><span class="p">])</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">visited</span><span class="p">[</span><span class="n">v</span><span class="p">])</span> <span class="p">{</span>
      <span class="n">dfs</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<h2 id="너비-우선-탐색breadth-first-search-bfs">너비 우선 탐색(Breadth First Search, BFS)</h2>

<p>또다른 그래프 탐색 방법중 하나인 너비 우선 탐색(이하 BFS)은 시작 정점에서부터 거리가 가까운 정점들부터 방문해나간다. BFS는 보통 그래프에서 최단 경로 문제를 풀때 많이 사용된다. 시간복잡도는 <script type="math/tex">O(V+E)</script>이다.</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="kt">int</span> <span class="n">V</span><span class="p">;</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">adj</span><span class="p">[</span><span class="n">MAX_V</span><span class="p">];</span>

<span class="kt">void</span> <span class="nf">bfs</span><span class="p">(</span><span class="kt">int</span> <span class="n">source</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">dist</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">INF</span><span class="p">);</span>
  <span class="n">dist</span><span class="p">[</span><span class="n">source</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"visit vertex 0 (Layered 0)"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;;</span>
  <span class="n">queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">q</span><span class="p">;</span>
  <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">source</span><span class="p">);</span>
  <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">u</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">();</span> <span class="n">q</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">v</span> <span class="o">:</span> <span class="n">adj</span><span class="p">[</span><span class="n">u</span><span class="p">])</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">dist</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">==</span> <span class="n">INF</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">dist</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">dist</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"visit vertex "</span> <span class="o">&lt;&lt;</span> <span class="n">v</span> <span class="o">&lt;&lt;</span> <span class="s">" (Layered "</span> <span class="o">&lt;&lt;</span> <span class="n">dist</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">")"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<h2 id="컴포넌트components-찾기">컴포넌트(Components) 찾기</h2>

<p>그래프에서 컴포넌트(connected component)란 다음 두 가지 특성을 만족하는 정점의 부분 집합이다.</p>

<ul>
  <li>부분 집합의 임의의 두 점 사이에는 경로(path)가 존재해야 한다.</li>
  <li>부분 집합내의 임의의 정점 u와 부분 집합에 포함되지 않은 정점 v 사이에 경로가 존재해서는 안된다. (가능한 최대 부분 집합이어야 한다는 것)</li>
</ul>

<p>무방향 그래프에서 컴포넌트들은 다음과 같이 DFS로 쉽게 찾아낼 수 있다.</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="kt">int</span> <span class="n">V</span><span class="p">;</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">adj</span><span class="p">[</span><span class="n">MAX_V</span><span class="p">];</span>
<span class="kt">bool</span> <span class="n">visited</span><span class="p">[</span><span class="n">MAX_V</span><span class="p">];</span>

<span class="kt">void</span> <span class="nf">dfs</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">visited</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">u</span> <span class="o">&lt;&lt;</span> <span class="sc">' '</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">v</span> <span class="o">:</span> <span class="n">adj</span><span class="p">[</span><span class="n">u</span><span class="p">])</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">visited</span><span class="p">[</span><span class="n">v</span><span class="p">])</span>
      <span class="n">dfs</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">find_connected_components</span><span class="p">()</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">V</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">visited</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span> <span class="c1">// visited[]: initially all false
</span>      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Connected Component "</span> <span class="o">&lt;&lt;</span> <span class="n">cnt</span><span class="o">++</span> <span class="o">&lt;&lt;</span> <span class="s">": "</span><span class="p">;</span>
      <span class="n">dfs</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<h2 id="위상-정렬topological-sort">위상 정렬(Topological Sort)</h2>

<p>위상 정렬은 방향 그래프의 정점들을 정점들 사이의 간선 방향을 거스르지 않도록 나열하는 것으로 의존성이 있는 작업들을 목록이 있을 때, 어떤 순서로 작업을 해야 하는지 계산하는데 사용한다.</p>

<p>DAG(Directed Asyclic Graph)에서는 다음과 같이 DFS를 응용하여 위상 정렬을 할 수 있다. (사이클이 존재하는 방향 그래프에서는 위상 정렬을 할 수 없다)</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="kt">int</span> <span class="n">V</span><span class="p">;</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">adj</span><span class="p">[</span><span class="n">MAX_V</span><span class="p">];</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">order</span><span class="p">;</span>
<span class="kt">bool</span> <span class="n">visited</span><span class="p">[</span><span class="n">MAX_V</span><span class="p">];</span>

<span class="kt">void</span> <span class="nf">dfs</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">visited</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">v</span> <span class="o">:</span> <span class="n">adj</span><span class="p">[</span><span class="n">u</span><span class="p">])</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">visited</span><span class="p">[</span><span class="n">v</span><span class="p">])</span> <span class="p">{</span>
      <span class="n">dfs</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="n">order</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">u</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">topological_sort</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">V</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">visited</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
      <span class="n">dfs</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
  <span class="n">reverse</span><span class="p">(</span><span class="n">order</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">order</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"order: "</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">order</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">order</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="sc">' '</span><span class="p">;</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>

<h2 id="이분-그래프-검사하기bipartite-graph-checking">이분 그래프 검사하기(Bipartite Graph Checking)</h2>

<p>이분 그래프란 다음 두 가지 특성을 만족하는 특수 그래프를 말한다.</p>

<ul>
  <li>그래프의 모든 정점들을 두 개의 상호 배타적 집합 A, B로 분할할 수 있다.</li>
  <li>이때, 그래프의 모든 간선은 A의 정점과 B의 정점을 잇는 형태여야만 한다. (즉, A내의 어느 두 정점도 간선으로 연결되어 있지 않다. B도 마찬가지)</li>
</ul>

<p>이분 그래프인지 검사하는 방법 또한 DFS로 쉽게 구현 가능하다. 서로 인접한 두 정점을 다른 색으로 칠해가는데 인접한 두 정점의 색이 같아지는 상황이 발생하면 이분 그래프가 아님을 확인할 수 있다.</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="kt">int</span> <span class="n">V</span><span class="p">;</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">adj</span><span class="p">[</span><span class="n">MAX_V</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">color</span><span class="p">[</span><span class="n">MAX_V</span><span class="p">];</span>

<span class="kt">bool</span> <span class="nf">set_color</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span><span class="p">,</span> <span class="kt">int</span> <span class="n">u_color</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">color</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">u_color</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">v</span> <span class="o">:</span> <span class="n">adj</span><span class="p">[</span><span class="n">u</span><span class="p">])</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">color</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">==</span> <span class="n">INF</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">set_color</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">color</span><span class="p">[</span><span class="n">u</span><span class="p">]))</span>
      <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">color</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">==</span> <span class="n">color</span><span class="p">[</span><span class="n">u</span><span class="p">])</span>
      <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">bool</span> <span class="nf">is_bipartite</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">V</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="n">color</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">INF</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">V</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">color</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">INF</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">set_color</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
      <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
  <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>

<h2 id="사이클-찾기cycle-detection">사이클 찾기(Cycle Detection)</h2>

<p>추가 예정…</p>

<p>사이클과 관련된 그래프 특성</p>

<ul>
  <li>모든 정점의 나가는 간선의 차수가 1인 경우, 각각의 컴포넌트들은 최대 1개의 cycle을 갖는다.</li>
  <li>무방향 그래프가 주어졌을 때, 이 그래프에 홀수 길이의 사이클이 존재하지 않는다는 말은 주어진 그래프가 이분 그래프라는 말과 동치다.</li>
</ul>

<h2 id="오일러-서킷eulerian-circuit-찾기">오일러 서킷(Eulerian Circuit) 찾기</h2>

<p>추가 예정…</p>

<h2 id="dfs-스패닝-트리dfs-spanning-tree">DFS 스패닝 트리(DFS Spanning Tree)</h2>

<p>그래프의 단절점, 단절선, 강결합 컴포넌트를 찾는 알고리즘등과 같이 DFS를 응용하여 문제를 해결하려고 할 때, 알아두면 도움이 되는 개념이 있다. DFS 스패닝 트리와 그에 따른 간선 분류다. 어떤 연결된 그래프에 DFS를 수행할 때 탐색이 따라가는 간선들을 모아보면 트리 형태를 이루는 것을 알 수 있다. 이를 DFS 스패닝 트리라고 하는데 이러한 DFS 스패닝 트리를 생성하고 나면 그래프의 모든 간선을 다음과 같이 네 가지 중 하나로 분류할 수 있다.</p>

<p><img src="http://localhost:4000/assets/dfs-spanning-tree.png" alt="dfs-spanning-tree" /></p>

<ul>
  <li>트리 간선(tree edge): 스패닝 트리에 포함된 간선</li>
  <li>순방향 간선(forward edge): 스패닝 트리를 구성하는 트리 간선은 아니지만, 스패닝 트리의 선조에서 자손으로 연결되는 간선</li>
  <li>역방향 간선(back edge): 스패닝 트리의 자손에서 선조로 연결되는 간선 (방향 그래프에서는 순방향 간선과 구분이 없다)</li>
  <li>교차 간선(cross edge): 트리에서 선조와 자손 관계가 아닌 정점들 간에 연결된 간선 (방향 그래프에서만 존재)</li>
</ul>

<p>위에서 분류한 대로 방향 그래프의 간선을 구분하는 것은 DFS를 수행하는 동안 처리할 수 있다. 현재 정점 u에 방문 중일 때, 인접한 정점 v와의 간선을 어떻게 분류할지를 고민하면 된다.</p>

<p>만약 정점 v를 아직 방문하지 않았다면, 다음에 v를 방문하므로 간선 (u, v)는 트리 간선이 된다. 그런데 v를 이미 방문한 경우 순방향, 역방향, 교차 간선 중 하나가 된다. 이 세 가지를 다시 구분해야 한다.</p>

<p>순방향의 간선이 역방향, 교차 간선과 구분되는 것이 하나 있다. 현재 정점 u보다 나중에 방문된 정점 v와의 간선이라는 것이다. 따라서 각 정점의 방문 순서(시간)를 저장해두면 구분할 수 있다.</p>

<p>역방향 간선과 교차 간선은 방문 순서로 구분할 수는 없다. 둘다 현재 정점 u보다 먼저 방문된 정점 v와의 간선이기 때문이다. 이 둘의 차이는 쉽게 생각하면 시작 정점을 루트로 하는 DFS 스패닝 트리에서 정점 v가 정점 u의 조상 노드(부모 노드 포함)인지 확인하는 것이다. 이는 v에서의 탐색이 종료된 상태인지를 확인하면 된다. 만약 v에서의 탐색이 종료하지 않았다면 역방향 간선, 종료했다면 교차 간선이라고 판단할 수 있다.</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="kt">int</span> <span class="n">V</span><span class="p">;</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">adj</span><span class="p">[</span><span class="n">MAX_V</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">discovered</span><span class="p">[</span><span class="n">MAX_V</span><span class="p">];</span> <span class="c1">// initially set all -1
</span><span class="kt">bool</span> <span class="n">finished</span><span class="p">[</span><span class="n">MAX_V</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">dfs_spanning_tree</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// in directed graph
</span>  <span class="n">discovered</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">counter</span><span class="o">++</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">v</span> <span class="o">:</span> <span class="n">adj</span><span class="p">[</span><span class="n">u</span><span class="p">])</span> <span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"edge("</span> <span class="o">&lt;&lt;</span> <span class="n">u</span> <span class="o">&lt;&lt;</span> <span class="s">", "</span> <span class="o">&lt;&lt;</span> <span class="n">v</span> <span class="o">&lt;&lt;</span> <span class="s">") is a "</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">discovered</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"tree edge.</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
      <span class="n">dfs_spanning_tree</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">discovered</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">discovered</span><span class="p">[</span><span class="n">v</span><span class="p">])</span>
      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"forward edge.</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">finished</span><span class="p">[</span><span class="n">v</span><span class="p">])</span>
      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"back edge.</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="k">else</span>
      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"cross edge.</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">finished</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>

<h2 id="단절점articulation-points-cut-vertices-찾기">단절점(Articulation Points, Cut Vertices) 찾기</h2>

<p>무방향 그래프에서 정점 u와 u와 연결된 간선들을 지웠을 때,  u가 속해있는 컴포넌트가 두 개 이상으로 나뉘어질 때, 이 정점 u를 단절점(Cur Vertex 또는 Articulation Point)라고 한다. 이러한 단절점을 찾는 가장 간단한 방법은 어떤 정점을 지운 후, 컴포넌트의 개수가 증가했는지 확인하는 것으로 총 <script type="math/tex">V</script>번의 DFS를 수행 되지만, DFS 스패닝 트리를 관찰하면 보다 효율적으로 단절점을 찾을 수 있다. 임의의 정점으로부터  DFS를 수행하여 얻은 DFS 스패닝 트리가 아래와 같다고 하자.</p>

<p><img src="http://localhost:4000/assets/cut-vertex.png" alt="cut-vertex" /></p>

<p><script type="math/tex">u</script>의 자식 노드가 <script type="math/tex">v_1, v_2, v_2</script>이고, 이 <script type="math/tex">v_1, v_2, v_3</script> 각각을 루트로 하는 서브 트리가 형성되었다고 하자. 이때, 각각의 서브 트리와 <script type="math/tex">u</script>의 조상 노드가 모두 연결되어 있다면, (즉 역방향 간선이 존재하면) <script type="math/tex">u</script>를 없애도 컴포넌트가 나뉘어지지 않는다. 반대로 하나의 서브 트리라도 <script type="math/tex">u</script>의 선조들로 향하는 역방향 간선이 존재하지 않으면, <script type="math/tex">u</script>는 절단점이 된다.</p>

<p>단, 위의 상황은 <script type="math/tex">u</script>가 DFS 스패닝 트리의 루트 이외의 정점일 때 성립한다. 루트 정점일 때는 따로 처리해주어야 하는데, 루트 정점의 트리 간선이 1개라면 이 정점을 제거해도 그래프의 컴포넌트가 증가하지 않는다. 반대로 루트 정점은 트리 간선의 개수가 2개 이상이면 무조건 단절점이 된다.</p>

<p>아래와 같이 단절점을 찾는 코드를 구현할 수 있는데, 여기서 <strong><em>low[v]</em></strong>는 각 <script type="math/tex">v</script>의 서브 트리내의 정점에서 v의 부모인 u와의 간선을 제외한 역방향 간선을 통해 도달할 수 있는 방문 시간이 가장 빠른 정점을 기록한다. (여기서 방문 시간이 가장 빠른 정점이 최상위 정점이 된다. 그리고 방문 시간은 각 정점마다 다르기 때문에 각 정점을 구별할 수 있다.)  <strong><em>low[v]</em></strong>를 알고 있다면 <script type="math/tex">v</script>와 그 부모 <script type="math/tex">u</script>사이의 간선을 제거했을 때, <script type="math/tex">u</script>의 조상과의 연결이 끊키는지 확인할 수 있다.</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="kt">int</span> <span class="n">V</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">counter</span><span class="p">;</span> <span class="c1">// time counter
</span><span class="kt">int</span> <span class="n">discovered</span><span class="p">[</span><span class="n">MAX_V</span><span class="p">];</span> <span class="c1">// discovered[u]: time u visited
</span><span class="kt">int</span> <span class="n">low</span><span class="p">[</span><span class="n">MAX_V</span><span class="p">];</span> <span class="c1">// Top vertex('s visit time) reachable
</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">adj</span><span class="p">[</span><span class="n">MAX_V</span><span class="p">];</span>
<span class="kt">bool</span> <span class="n">cut_vertex</span><span class="p">[</span><span class="n">MAX_V</span><span class="p">];</span>

<span class="kt">void</span> <span class="nf">find_cut_vertices</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span><span class="p">,</span> <span class="kt">int</span> <span class="n">parent</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">root</span> <span class="o">=</span> <span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">low</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">discovered</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">counter</span><span class="o">++</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">children</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// for root
</span>  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">v</span> <span class="o">:</span> <span class="n">adj</span><span class="p">[</span><span class="n">u</span><span class="p">])</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">discovered</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">children</span><span class="o">++</span><span class="p">;</span> <span class="c1">// for root
</span>      <span class="n">find_cut_vertices</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">low</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">discovered</span><span class="p">[</span><span class="n">u</span><span class="p">])</span> <span class="p">{</span>
        <span class="n">cut_vertex</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="n">low</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">low</span><span class="p">[</span><span class="n">u</span><span class="p">],</span> <span class="n">low</span><span class="p">[</span><span class="n">v</span><span class="p">]);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="o">!=</span> <span class="n">parent</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">low</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">low</span><span class="p">[</span><span class="n">u</span><span class="p">],</span> <span class="n">discovered</span><span class="p">[</span><span class="n">v</span><span class="p">]);</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// for root
</span>    <span class="n">cut_vertex</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">children</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">?</span> <span class="nb">true</span> <span class="o">:</span> <span class="nb">false</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<h2 id="단절선bridges-찾기">단절선(Bridges) 찾기</h2>

<p>단절점과 유사하게 제거했을 때 컴포넌트의 개수를 증가시키는 간선을 단절점 또는 다리(bridge)라고 부른다. 이 단절선 역시 단절점을 구하는 것과 유사하게 구할 수 있다. DFS 중 현재 정점이 <script type="math/tex">u</script>이고, <script type="math/tex">u</script>와 인접한 정점이자 DFS 스패닝 트리상의 자식 정점인 <script type="math/tex">v</script>와의 간선 <script type="math/tex">(u, v)</script>이 단절선이 될 수 있는 경우를 고려해보자. DFS 스패닝 트리상 <script type="math/tex">v</script>를 루트로 하는 서브 트리가 생성될 것이다. 이 서브 트리에서 <script type="math/tex">(u, v)</script>를 제외한 간선을 통해 정점 <script type="math/tex">v</script>의 조상 노드로 향하는 역방향 간선이 존재하지 않으면, 간선 <script type="math/tex">(u, v)</script>를 지웠을 때 이 서브 트리는 분리된다. 따라서 이러한 간선 <script type="math/tex">(u, v)</script>가 단절선이 된다. 구현 코드는 단절점 코드와 상당히 유사하다.</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="kt">int</span> <span class="n">V</span><span class="p">,</span> <span class="n">counter</span><span class="p">,</span> <span class="n">discovered</span><span class="p">[</span><span class="n">MAX_V</span><span class="p">],</span> <span class="n">low</span><span class="p">[</span><span class="n">MAX_V</span><span class="p">];</span> <span class="c1">// initially set all -1
</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">adj</span><span class="p">[</span><span class="n">MAX_V</span><span class="p">];</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">bridges</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">find_bridges</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span><span class="p">,</span> <span class="kt">int</span> <span class="n">parent</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">low</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">discovered</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">counter</span><span class="o">++</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">v</span> <span class="o">:</span> <span class="n">adj</span><span class="p">[</span><span class="n">u</span><span class="p">])</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">discovered</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">find_bridges</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">u</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">low</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">discovered</span><span class="p">[</span><span class="n">u</span><span class="p">])</span> <span class="p">{</span>
        <span class="n">bridges</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="n">min</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">),</span> <span class="n">max</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)));</span>
      <span class="p">}</span>
      <span class="n">low</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">low</span><span class="p">[</span><span class="n">u</span><span class="p">],</span> <span class="n">low</span><span class="p">[</span><span class="n">v</span><span class="p">]);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="o">!=</span> <span class="n">parent</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">low</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">low</span><span class="p">[</span><span class="n">u</span><span class="p">],</span> <span class="n">discovered</span><span class="p">[</span><span class="n">v</span><span class="p">]);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<h2 id="강결합-컴포넌트strongly-connected-components-찾기">강결합 컴포넌트(Strongly Connected Components) 찾기</h2>

<p>방향 그래프에서 정의되는 개념중에 강결합 요소가 있다. 다음 조건들을 만족하는 정점들의 집합을 강결합 컴포넌트(Strongly Connected Components, 줄여서 SCC)라고 부른다.</p>

<ol>
  <li>SCC내의 임의의 두 정점 <script type="math/tex">u, v</script> 사이에 <script type="math/tex">u</script> -&gt; <script type="math/tex">v</script> 경로, <script type="math/tex">v</script> -&gt; <script type="math/tex">u</script> 경로가 모두 존재한다.</li>
  <li>서로 다른 SCC에 속하는 임의의 두 정점 <script type="math/tex">u, v</script>에 대해 <script type="math/tex">u</script> -&gt; <script type="math/tex">v</script> 경로, <script type="math/tex">v</script> -&gt; <script type="math/tex">u</script> 경로가 모두 존재할 수 없다. (= SCC는 가능한 최대 집합이어야 한다)</li>
</ol>

<p>방향 그래프에서 각각의 강결합 컴포넌트를 구분하는 대표적인 알고리즘으로는 타잔 알고리즘과 코사라주 알고리즘이 있다.</p>

<h3 id="타잔-알고리즘targan-algorithm">타잔 알고리즘(Targan algorithm)</h3>

<p>타잔 알고리즘은 DFS를 통해 생성되는 DFS 스패닝 트리와 그에 따른 간선 분류를 통해서 방향 그래프의 SCC를 구한다. 방향 그래프의 DFS 스패닝 트리를 관찰해보면 알 수 있는 사실이 몇 가지 있다. 모든 SCC에 대해 SCC의 한 정점을 루트로 하고, SCC를 이루는 정점들은 모두 포함하는 서브 트리가 DFS 스패닝 트리에 존재한다는 것이다. 이를 만족하지 않는 정점이 있다고 가정하면 금방 모순이 된다는 것을 확인할 수 있다.</p>

<p>그러므로 DFS를 수행하면서 각 정점 <script type="math/tex">u</script>에 대해 정점 <script type="math/tex">u</script>가 자신이 속해 있는 SCC를 포함하는 서브 트리의 루트가 될 수 있는지를 판단하면 된다. 정점 <script type="math/tex">u</script>가 서브 트리의 루트가 될 수 있다고 판단되면 자신을 포함하여 서브 트리상에서 아직 SCC로 묶이지 않은 정점들과 하나의 SCC를 이룰 수 있게 된다. <script type="math/tex">u</script>를 루트로 하는 서브 트리에서 <script type="math/tex">u</script>와 같은 SCC에 속할 수 없는 정점들은 DFS의 특성상 이미 <script type="math/tex">u</script>를 루트로 하는 서브 트리 내부의 또다른 서브 트리들은 형성하면서 각각의 SCC로 배정되어 있기 때문에 가능한 일이다.</p>

<p>각 정점 <script type="math/tex">u</script>에 대해 정점 <script type="math/tex">u</script>가 자신이 속해있는 SCC를 포함하는 서브 트리의 루트인지 확인하는 것은 단절점, 단절선을 구할 때와 유사하게 <strong><em>low[u]</em></strong>를 통해 알 수 있다. <strong><em>low[u]</em></strong>가 <script type="math/tex">u</script>의 방문 시간과 일치한다면 루트가 된다. 무방향 그래프에서 정의된 단절점, 단절선과 다르게 SCC는 방향 그래프에서 정의되는 개념이기 때문에 <strong><em>low[u]</em></strong>를 구할 때, 교차 간선에 유의해야 한다. 현재 정점이 <script type="math/tex">u</script>일 때 <strong><em>low[u]</em></strong>에 대한 정보는 다음과 같이 얻을 수 있다.</p>

<ul>
  <li>일단, <strong><em>low[u] &lt;= discovered[u]</em></strong> 인 것은 당연하다.</li>
  <li>트리 간선을 타고가 만나는 정점 v와 v를 루트로 하는 서브 트리내의 정점은 u를 루트로 하느 서브 트리내의 정점에 모두 포함되므로 <strong><em>low[u] &lt;= low[v]</em></strong> 이다.</li>
  <li>순방향 간선을 타고가 만나는 정점 v에서 얻을 수 있는 정보는 트리 간선을 통해 얻을 수 있으므로 무시해도 된다.</li>
  <li>역방향 간선을 타고가 만나는 정점 v는 u의 조상이므로 <strong><em>low[u] &lt;= discovered[v]</em></strong> 가 된다.</li>
  <li>교차 간선을 타고가 만나는 정점 v는 u의 조상도 아니고, 서브 트리내의 정점도 아니다. 하지만 v가 아직 별도의 SCC로 묶여있지 않은 상황이면 u와 v가 같은 SCC로 묶이게 되므로, 이 경우 <strong>low[u] &lt;= discovered[v]</strong> 가 된다.</li>
</ul>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="kt">int</span> <span class="n">V</span><span class="p">;</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">adj</span><span class="p">[</span><span class="n">MAX_V</span><span class="p">];</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">discovered</span><span class="p">,</span> <span class="n">low</span><span class="p">,</span> <span class="n">scc_id</span><span class="p">;</span> <span class="c1">// initially set all -1
</span><span class="n">stack</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">s</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">counter</span><span class="p">,</span> <span class="n">scc_counter</span><span class="p">;</span> <span class="c1">// initially set all 0
</span>
<span class="kt">void</span> <span class="nf">targan_scc</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">low</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">discovered</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">counter</span><span class="o">++</span><span class="p">;</span>
  <span class="n">s</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">u</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">v</span> <span class="o">:</span> <span class="n">adj</span><span class="p">[</span><span class="n">u</span><span class="p">])</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">discovered</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">targan_scc</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
      <span class="n">low</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">low</span><span class="p">[</span><span class="n">u</span><span class="p">],</span> <span class="n">low</span><span class="p">[</span><span class="n">v</span><span class="p">]);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">scc_id</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">low</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">low</span><span class="p">[</span><span class="n">u</span><span class="p">],</span> <span class="n">discovered</span><span class="p">[</span><span class="n">v</span><span class="p">]);</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">low</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">==</span> <span class="n">discovered</span><span class="p">[</span><span class="n">u</span><span class="p">])</span> <span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
      <span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">top</span><span class="p">();</span> <span class="n">s</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
      <span class="n">scc_id</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">scc_counter</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">u</span> <span class="o">==</span> <span class="n">v</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">scc_counter</span><span class="o">++</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<h3 id="코사라주-알고리즘-kosarajus-algorithm">코사라주 알고리즘 (Kosaraju’s algorithm)</h3>

<p>코사라주 알고리즘(Kosaraju’s algorithm)은 두 번의 DFS (정방향 DFS 한 번, 역방향 DFS 한 번)로 방향 그래프의 강한 컴포넌트들을 구분한다.</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="kt">int</span> <span class="n">V</span><span class="p">;</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">adj</span><span class="p">[</span><span class="n">MAX_V</span><span class="p">],</span> <span class="n">radj</span><span class="p">[</span><span class="n">MAX_V</span><span class="p">],</span> <span class="n">sid</span><span class="p">,</span> <span class="n">order</span><span class="p">;</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">visited</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">dfs</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">visited</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">v</span> <span class="o">:</span> <span class="n">adj</span><span class="p">[</span><span class="n">u</span><span class="p">])</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">visited</span><span class="p">[</span><span class="n">v</span><span class="p">])</span> <span class="p">{</span>
      <span class="n">dfs</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="n">order</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">u</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">rdfs</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span><span class="p">,</span> <span class="kt">int</span> <span class="n">id</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">sid</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">id</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">v</span> <span class="o">:</span> <span class="n">radj</span><span class="p">[</span><span class="n">u</span><span class="p">])</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">sid</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">rdfs</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">kosaraju_scc</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">visited</span><span class="p">.</span><span class="n">assign</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">u</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">u</span> <span class="o">&lt;</span> <span class="n">V</span><span class="p">;</span> <span class="n">u</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">visited</span><span class="p">[</span><span class="n">u</span><span class="p">])</span> <span class="p">{</span>
      <span class="n">dfs</span><span class="p">(</span><span class="n">u</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="n">reverse</span><span class="p">(</span><span class="n">order</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">order</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
  <span class="kt">int</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">sid</span><span class="p">.</span><span class="n">assign</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">u</span> <span class="o">:</span> <span class="n">order</span><span class="p">)</span>  <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">sid</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">rdfs</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">id</span><span class="o">++</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">id</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>

<h3 id="2-sat-문제">2-SAT 문제</h3>

<p>추가 예정…</p>

<h2 id="연습-문제">연습 문제</h2>

<p><strong>BOJ 2331 반복수열 (<a href="https://www.acmicpc.net/problem/2331">문제 보기</a>)</strong></p>

<p><strong>BOJ 2487 섞기 수열 (<a href="https://www.acmicpc.net/problem/2487">문제 보기</a>)</strong></p>

<p><strong>BOJ 2234 성곽 (<a href="https://www.acmicpc.net/problem/2234">문제 보기</a>)</strong></p>

<p><strong>BOJ 9466 텀 프로젝트 (<a href="https://www.acmicpc.net/problem/9466">문제 보기</a>)</strong></p>

<p><strong>BOJ 2617 구슬 찾기 (<a href="https://www.acmicpc.net/problem/2617">문제 보기</a>)</strong></p>

<p><strong>BOJ 2178 미로 탐색 (<a href="https://www.acmicpc.net/problem/2178">문제 보기</a>)</strong></p>

<p><strong>BOJ 13903 출근 (<a href="https://www.acmicpc.net/problem/13903">문제 보기</a>)</strong></p>

<p><strong>BOJ 2146 다리 만들기 (<a href="https://www.acmicpc.net/problem/2146">문제 보기</a>)</strong></p>

<p><strong>BOJ 1697 숨바꼭질 (<a href="https://www.acmicpc.net/problem/1697">문제 보기</a>)</strong></p>

<p><strong>BOJ 12851 숨바꼭질 2 (<a href="https://www.acmicpc.net/problem/12851">문제 보기</a>)</strong></p>

<p><strong>BOJ 2206 벽 부수고 이동하기 (<a href="https://www.acmicpc.net/problem/2206">문제 보기</a>)</strong></p>

<p><strong>BOJ 1734 교통 체계 (<a href="https://www.acmicpc.net/problem/1734">문제 보기</a>)</strong></p>

<h2 id="참고-자료">참고 자료</h2>

<ul>
  <li>프로그래밍 대회에서 배우는 알고리즘 문제해결전략, 구종만</li>
  <li>Competive Programming 3, Steven Halim</li>
</ul>

</div>

<div class="share">
	<br>
    <p>Share this post with: </p>
	<a href="https://twitter.com/intent/tweet?text=그래프 탐색(Graph Search)@&amp;url=http://localhost:4000/algorithm/2017/08/15/Graph-Search.html" class="twitter-share">
		<span class="fa-stack fa-lg">
			<i class="fa fa-circle fa-stack-2x"></i>
			<i class="fa fa-twitter fa-stack-1x fa-inverse"></i>
		</span>
	</a>

	<a href="https://www.facebook.com/sharer/sharer.php?u=http://localhost:4000/algorithm/2017/08/15/Graph-Search.html" class="facebook-share">
		<span class="fa-stack fa-lg">
			<i class="fa fa-circle fa-stack-2x"></i>
			<i class="fa fa-facebook fa-stack-1x fa-inverse"></i>
		</span>
	</a>

	<a href="https://plus.google.com/share?url=http://localhost:4000/algorithm/2017/08/15/Graph-Search.html" class="googleplus-share">
		<span class="fa-stack fa-lg">
			<i class="fa fa-circle fa-stack-2x"></i>
			<i class="fa fa-google-plus fa-stack-1x fa-inverse"></i>
		</span>
	</a>
</div>


<div class="comments">
    
		<div id="disqus_thread"></div>
		<script>

		/**
		*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
		*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
		/*
		var disqus_config = function () {
		this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
		this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
		};
		*/
		(function() { // DON'T EDIT BELOW THIS LINE
		var d = document, s = d.createElement('script');
		s.src = 'https://museop.disqus.com/embed.js';
		s.setAttribute('data-timestamp', +new Date());
		(d.head || d.body).appendChild(s);
		})();
		</script>
		<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
                            
    
</div>



<div class="related">
  <h2>Related Posts</h2>
  <ul class="related-posts">
    
      <li>
        <h3>
          <a href="/algorithm/2017/09/12/Binary-Search.html">
            이진 탐색(Binary Search)
            <small>12 Sep 2017</small>
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/data%20structure/2017/09/12/Binary-Search-Tree.html">
            이진검색트리(Binary Search Tree)
            <small>12 Sep 2017</small>
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/data%20structure/2017/09/11/Square-Decomposition.html">
            평방 분할 기법(Square Root Decomposition)
            <small>11 Sep 2017</small>
          </a>
        </h3>
      </li>
    
  </ul>
</div>

      </div>
    </div>

    <label for="sidebar-checkbox" class="sidebar-toggle"></label>

    <script>
      (function(document) {
        var toggle = document.querySelector('.sidebar-toggle');
        var sidebar = document.querySelector('#sidebar');
        var checkbox = document.querySelector('#sidebar-checkbox');

        document.addEventListener('click', function(e) {
          var target = e.target;

          if(!checkbox.checked ||
             sidebar.contains(target) ||
             (target === checkbox || target === toggle)) return;

          checkbox.checked = false;
        }, false);
      })(document);
    </script>
  </body>
</html>
