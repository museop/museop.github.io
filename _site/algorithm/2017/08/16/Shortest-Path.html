<!DOCTYPE html>
<html lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      최단 경로(Shortest Path) &middot; Pleasure of Learning
    
  </title>
  <!-- FONT -->
  <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css" rel="stylesheet" />

  <!-- CSS -->
  <link rel="stylesheet" href="/public/css/poole.css">
  <link rel="stylesheet" href="/public/css/syntax.css">
  <link rel="stylesheet" href="/public/css/lanyon.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Serif:400,400italic,700%7CPT+Sans:400">
  <link rel="stylesheet" href="/public/css/mycss.css">
  
  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/public/apple-touch-icon-precomposed.png">
  <link rel="shortcut icon" href="/public/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">
  
  <!-- MathJax -->
  
	<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
  
</head>


  <body>
  
    <!-- Target for toggling the sidebar `.sidebar-checkbox` is for regular
     styles, `#sidebar-checkbox` for behavior. -->
<input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox">

<!-- Toggleable sidebar -->
<div class="sidebar" id="sidebar">
  <div class="sidebar-item">
    <p>This Blog is using my study.</p>
  </div>

  <nav class="sidebar-nav">
    <a class="sidebar-nav-item" href="/">Home</a>

    

    
    
      
        
      
    
      
        
      
    
      
        
          <a class="sidebar-nav-item" href="/about.html">About</a>
        
      
    
      
        
          <a class="sidebar-nav-item" href="/archive.html">Archive</a>
        
      
    
      
    
      
        
          <a class="sidebar-nav-item" href="/category.html">Category</a>
        
      
    
      
        
      
    
      
        
      
    
      
        
          <a class="sidebar-nav-item" href="/tags.html">Tags</a>
        
      
    
<!--
    <a class="sidebar-nav-item" href="/archive/v1.0.1.zip">Download</a>
    <a class="sidebar-nav-item" href="">GitHub project</a>
    <span class="sidebar-nav-item">Currently v1.0.1</span> -->
  </nav>

  <div class="sidebar-item">
    <p>
      &copy; 2018. All rights reserved.
    </p>
  </div>
</div>


    <!-- Wrap is the content to shift when toggling the sidebar. We wrap the
         content to avoid any CSS collisions with our real content. -->
    <div class="wrap">
      <div class="masthead">
        <div class="container">
          <h3 class="masthead-title">
            <a href="/" title="Home">Pleasure of Learning</a>
            <small></small>
          </h3>
        </div>
      </div>

      <div class="container content">
        <div class="post">
  <h1 class="post-title">최단 경로(Shortest Path)</h1>
  <span class="post-date"><time>16 Aug 2017</time></span>
  <div class="post-tags">
      
        <a class="post-tags-item" href="http://localhost:4000/tags#graph">
          <span>graph</span>
        </a>
      
        <a class="post-tags-item" href="http://localhost:4000/tags#shortest path">
          <span>shortest path</span>
        </a>
      
  </div>

  <p>가중치가 없는 그래프에서 두 정점 사이의 최단 거리는 BFS를 이용하면 쉽게 구할 수 있다. 만약 가중치가 있는 그래프에서 임의의 두 정점 사이의 최단 경로를 구해야 한다면 다른 방법을 찾아야 한다.</p>

<h2 id="단일-시작점-최단-경로">단일 시작점 최단 경로</h2>

<p>그래프에서 시작점 <strong><em>S</em></strong>가 존재하고, 이 정점으로부터 모든 정점 사이의 최단 경로를 구하는 유명한 최단 경로 알고리즘으로는 다익스트라 알고리즘과 벨만-포드 알고리즘이 있다.</p>

<h3 id="다익스트라dijkstra-알고리즘">다익스트라(Dijkstra) 알고리즘</h3>

<p>다익스트라 알고리즘은 시작 정점 <strong><em>S</em></strong> 로부터 가장 가까운 정점부터 방문해나가는 탐욕적 알고리즘이다. 가중치가 없는 그래프에서는 큐를 이용한 BFS로 이 작업을 수행하지만 가중치가 있는 그래프에서는 그렇지 못하다. 대신에 우선 순위 큐를 사용함으로써 이 작업을 수행한다. 시간복잡도는 <script type="math/tex">O(E \space log_2{  V }  )</script>이다.</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="kt">int</span> <span class="n">V</span><span class="p">;</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">adj</span><span class="p">[</span><span class="n">MAX_V</span><span class="p">];</span>

<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">dijkstra</span><span class="p">(</span><span class="kt">int</span> <span class="n">src</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">dist</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">INF</span><span class="p">);</span>
  <span class="n">dist</span><span class="p">[</span><span class="n">src</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">priority_queue</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;</span><span class="p">,</span> <span class="n">greater</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;&gt;</span> <span class="n">pq</span><span class="p">;</span>
  <span class="n">pq</span><span class="p">.</span><span class="n">push</span><span class="p">({</span> <span class="mi">0</span><span class="p">,</span> <span class="n">src</span> <span class="p">});</span>
  <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">pq</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">here</span> <span class="o">=</span> <span class="n">pq</span><span class="p">.</span><span class="n">top</span><span class="p">().</span><span class="n">second</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">cost</span> <span class="o">=</span> <span class="n">pq</span><span class="p">.</span><span class="n">top</span><span class="p">().</span><span class="n">first</span><span class="p">;</span>
    <span class="n">pq</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">dist</span><span class="p">[</span><span class="n">here</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">cost</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">edge</span> <span class="o">:</span> <span class="n">adj</span><span class="p">[</span><span class="n">here</span><span class="p">])</span> <span class="p">{</span>
      <span class="kt">int</span> <span class="n">there</span> <span class="o">=</span> <span class="n">edge</span><span class="p">.</span><span class="n">first</span><span class="p">;</span>
      <span class="kt">int</span> <span class="n">ncost</span> <span class="o">=</span> <span class="n">edge</span><span class="p">.</span><span class="n">second</span> <span class="o">+</span> <span class="n">cost</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">dist</span><span class="p">[</span><span class="n">there</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">ncost</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">dist</span><span class="p">[</span><span class="n">there</span><span class="p">]</span> <span class="o">=</span> <span class="n">ncost</span><span class="p">;</span>
        <span class="n">pq</span><span class="p">.</span><span class="n">push</span><span class="p">({</span> <span class="n">ncost</span><span class="p">,</span> <span class="n">there</span> <span class="p">});</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">dist</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>

<h3 id="벨만-포드bellman-ford-알고리즘">벨만-포드(Bellman-Ford) 알고리즘</h3>

<p>만일 주어진 그래프에 가중치가 음수인 간선이 있는 경우 다익스트라 알고리즘은 정상적으로 동작하지 않는다. 위에서 구현한 다익스트라 알고리즘은 우선 순위 큐를 사용하기 때문에 느리긴 하지만 음수 간선이 있어도 동작은 한다. 음수 간선이 존재하는 그래프의 단일 시작점 최단 경로를 구하려면 다른 알고리즘을 사용하는 것이 좋다. 음수 간선에서도 잘 동작하는 알고리즘으로 벨만-포드 알고리즘이 유명하다. 벨만-포드 알고리즘은 다음과 같은 간선의 특성을 기반으로 시작점으로부터 다른 모든 정점으로 가는 최단 거리를 완화(relax)해나간다.</p>

<p><br /></p>

<p><strong><em>dist[v] <script type="math/tex">\le</script> dist[u] + w(u, v)</em></strong>  (<strong><em>dist[u]</em></strong>: 시작점 <strong><em>S</em></strong>로부터 <strong><em>u</em></strong>로 가는 최단 거리)</p>

<p><br /></p>

<p><strong><em>S</em></strong>와 <strong><em>u</em></strong> 사이의 경로가 있다고 가정하면 <strong><em>dist[u]</em></strong>는 최대 <script type="math/tex">V-1</script>개의 간선을 거친 경로의 거리이다. 따라서 위의 특성을 이용하여 경로상의 간선의 개수가 1개, 2개, …, (최대) <script type="math/tex">V-1</script>개인 최단 경로를 확정해 나가면 각 정점까지의 최단 경로를 모두 찾을 수 있게 된다. 시간복잡도는 <script type="math/tex">O(VE)</script>가 된다.</p>

<p>음수 간선에서도 동작한다는 특징 외에 벨만-포드 알고리즘에 좋은점이 하나 더 있다. 그래프에 음수 사이클이 존재한다면 최단 경로 문제는 의미가 없어진다. 위에서 구현한 다익스트라 알고리즘도 음수 사이클이 존재하는 그래프에서 실행시킨다면 무한 루프에 빠지게 된다. 벨만-포드 알고리즘은 최대 <script type="math/tex">V-1</script>의 완화 작업을 수행하기 때문에 무한 루프에 빠질 우려는 없다. 더욱이  <script type="math/tex">V-1</script>번의 완화 이후 더 완화될 수 있는 정점이 존재한다면 주어진 그래프는 음수 사이클을 가졌다고 판정할 수 있다.</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="kt">int</span> <span class="n">V</span><span class="p">;</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">adj</span><span class="p">[</span><span class="n">MAX_V</span><span class="p">];</span>

<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">bellmenford</span><span class="p">(</span><span class="kt">int</span> <span class="n">src</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">dist</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">INF</span><span class="p">);</span>
  <span class="n">dist</span><span class="p">[</span><span class="n">src</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="n">updated</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">V</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">updated</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">here</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">here</span> <span class="o">&lt;</span> <span class="n">V</span><span class="p">;</span> <span class="n">here</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">edge</span> <span class="o">:</span> <span class="n">adj</span><span class="p">[</span><span class="n">here</span><span class="p">])</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">there</span> <span class="o">=</span> <span class="n">edge</span><span class="p">.</span><span class="n">first</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">cost</span> <span class="o">=</span> <span class="n">edge</span><span class="p">.</span><span class="n">second</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">dist</span><span class="p">[</span><span class="n">here</span><span class="p">]</span> <span class="o">!=</span> <span class="n">INF</span> <span class="o">&amp;&amp;</span> <span class="n">dist</span><span class="p">[</span><span class="n">there</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">dist</span><span class="p">[</span><span class="n">here</span><span class="p">]</span> <span class="o">+</span> <span class="n">cost</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">dist</span><span class="p">[</span><span class="n">there</span><span class="p">]</span> <span class="o">=</span> <span class="n">dist</span><span class="p">[</span><span class="n">here</span><span class="p">]</span> <span class="o">+</span> <span class="n">cost</span><span class="p">;</span>
          <span class="n">updated</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">updated</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">updated</span><span class="p">);</span>  <span class="c1">// if updated: true, then exists negative cycle.
</span>  <span class="k">return</span> <span class="n">dist</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>

<h3 id="shortest-path-fast-algorithmspfa">Shortest-Path-Fast-Algorithm(SPFA)</h3>

<p>두안 판딩(Dual Fanding)이라는 중국인에 의해 발표된 알고리즘으로 큐를 활용하여 벨만-포드 알고리즘에서 불필요한 연산들을 제거한 알고리즘이다. 시간복잡도는 <script type="math/tex">O(VE)</script>로 벨만-포드와 같지만 보통 더 빠르게 동작한다고 한다. 음수 사이클의 유무는 큐에 <script type="math/tex">V</script>번 이상 삽입되는 정점의 유무로 확인할 수 있다.</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="kt">int</span> <span class="n">V</span><span class="p">,</span> <span class="n">E</span><span class="p">;</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">adj</span><span class="p">[</span><span class="n">MAX_V</span><span class="p">];</span>

<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">spfa</span><span class="p">(</span><span class="kt">int</span> <span class="n">src</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">q</span><span class="p">;</span>
  <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">src</span><span class="p">);</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">in_queue</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
  <span class="n">in_queue</span><span class="p">[</span><span class="n">src</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">dist</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">INF</span><span class="p">),</span> <span class="n">inserted</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="n">dist</span><span class="p">[</span><span class="n">src</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">inserted</span><span class="p">[</span><span class="n">src</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">here</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">();</span> <span class="n">q</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
    <span class="n">in_queue</span><span class="p">[</span><span class="n">here</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">edge</span> <span class="o">:</span> <span class="n">adj</span><span class="p">[</span><span class="n">here</span><span class="p">])</span> <span class="p">{</span>
      <span class="kt">int</span> <span class="n">there</span> <span class="o">=</span> <span class="n">edge</span><span class="p">.</span><span class="n">first</span><span class="p">;</span>
      <span class="kt">int</span> <span class="n">cost</span> <span class="o">=</span> <span class="n">edge</span><span class="p">.</span><span class="n">second</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">dist</span><span class="p">[</span><span class="n">here</span><span class="p">]</span> <span class="o">!=</span> <span class="n">INF</span> <span class="o">&amp;&amp;</span> <span class="n">dist</span><span class="p">[</span><span class="n">there</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">dist</span><span class="p">[</span><span class="n">here</span><span class="p">]</span> <span class="o">+</span> <span class="n">cost</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">dist</span><span class="p">[</span><span class="n">there</span><span class="p">]</span> <span class="o">=</span> <span class="n">dist</span><span class="p">[</span><span class="n">here</span><span class="p">]</span> <span class="o">+</span> <span class="n">cost</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">in_queue</span><span class="p">[</span><span class="n">there</span><span class="p">])</span> <span class="p">{</span>
          <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">there</span><span class="p">);</span>
          <span class="n">in_queue</span><span class="p">[</span><span class="n">there</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
          <span class="n">inserted</span><span class="p">[</span><span class="n">there</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
          <span class="c1">// if some vertex that enters the queue for over V - 1 times,
</span>          <span class="c1">// graph has negative cycle.
</span>          <span class="n">assert</span><span class="p">(</span><span class="n">inserted</span><span class="p">[</span><span class="n">there</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">V</span><span class="p">);</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">dist</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>

<h3 id="0-1-bfs">0-1 BFS</h3>

<p>그래프의 가중치가 0 또는 1인 경우에 대해서 생각해보자. 이 경우 다익스트라 알고리즘을 사용하면 <script type="math/tex">O(E\space log_2V)</script>에 해결할 수 있다. 하지만 자료 구조 덱(deque)를 이용하면 <script type="math/tex">O(V+E)</script>만에 문제를 해결할 수 있다. 현재 정점 <script type="math/tex">u</script>를 방문중일 때, 인접한 정점 <script type="math/tex">v</script>로 가는 간선의 가중치가 0이라면  <script type="math/tex">v</script>를 덱에 앞에다 넣고, 1이라면 뒤에다 넣으면 된다. 조금 정리를 해보면 단일 시작점 최단 경로를 구할 때, 간선의 가중치에 따라 사용하는 자료 구조는 다음과 같다.</p>

<ul>
  <li>모든 간선의 가중치가 0: 큐(queue)</li>
  <li>모든 간선의 가중치가 0 또는 1: 덱(deque)</li>
  <li>간선의 가중치가 제각각: 우선순위 큐(priority queue)</li>
</ul>

<h2 id="모든-쌍-최단-경로">모든 쌍 최단 경로</h2>

<p>그래프의 임의의 두 정점쌍에 대한 최단 경로를 모두 구하고자 할 때는 다익스트라나 벨만 포드 알고리즘을 <script type="math/tex">V</script>번 수행하여 구할 수도 있지만, 플로이드-워셜이라는 보다 효율적인 알고리즘을 사용할 수 있다.</p>

<h3 id="플로이드-워셜floyd-warshell-알고리즘">플로이드-워셜(Floyd-Warshell) 알고리즘</h3>

<p>플로이드-워셜 알고리즘은 동적 계획법(dynamic programming)을 이용하여 두 정점 사이의 최단 경로를 계산한다.  <script type="math/tex">dist[k][u][v]</script>를 <strong><em>u</em></strong>에서 <strong>{ 1, 2, …, k }</strong> 내의 정점들을 경유점을 하여(경유해도 되고, 안해도 됨) <strong><em>v</em></strong>에 도달할 수 있는 최단 거리라고 하면 다음과 같은 관계식을 얻을 수 있다.</p>

<p><br /></p>

<script type="math/tex; mode=display">dist[k][u][v] =min\begin{cases}dist[k-1][u][k] + dist[k-1][k][v]  \\ dist[k-1[u][v] \end{cases}</script>

<p><br /></p>

<p>이와 같은 관계식을 토대로 아래와 같이 코드로 구현할 수 있다. 눈여겨볼만한 부분은 <script type="math/tex">dist[k][?][?]</script>를 구할 때, <script type="math/tex">dist[k-1][?][?]</script>만 필요하므로 슬라이딩 윈도우 기법으로 메모리 사용량을 줄인 부분이다. 초기 <script type="math/tex">dist[u][v]</script>는 <strong><em>u</em></strong>에서 <strong><em>v</em></strong>로 가는 간선의 가중치를 두고, 간선이 없으면 매우 큰 값(INF)을 넣어두면 된다(다만, INF + INF시 오버플로가 발생하면 안된다). 시간복잡도는 <script type="math/tex">O(V^3)</script>이 된다.</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="kt">int</span> <span class="n">V</span><span class="p">;</span>
<span class="cm">/* initially set dist[u][v] = w (if there is edge of weight w from u to v)
             set dist[u][v] = INF (if there is no edge from u to v) */</span>
<span class="kt">int</span> <span class="n">dist</span><span class="p">[</span><span class="n">MAX_V</span><span class="p">][</span><span class="n">MAX_V</span><span class="p">];</span>

<span class="kt">void</span> <span class="nf">floyd</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">u</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">u</span> <span class="o">&lt;</span> <span class="n">V</span><span class="p">;</span> <span class="n">u</span><span class="o">++</span><span class="p">)</span>
    <span class="n">dist</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">V</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">u</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">u</span> <span class="o">&lt;</span> <span class="n">V</span><span class="p">;</span> <span class="n">u</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">v</span> <span class="o">&lt;</span> <span class="n">V</span><span class="p">;</span> <span class="n">v</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">dist</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">dist</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">],</span> <span class="n">dist</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="n">dist</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">v</span><span class="p">]);</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<h2 id="연습-문제">연습 문제</h2>

<p><strong>BOJ 1916 최소비용 구하기 (<a href="https://www.acmicpc.net/problem/1916">문제 보기</a>)</strong></p>

<p><strong>BOJ 1238 파티 (<a href="https://www.acmicpc.net/problem/1238">문제 보기</a>)</strong></p>

<p><strong>BOJ 1261 알고스팟 (<a href="https://www.acmicpc.net/problem/1261">문제 보기</a>)</strong></p>

<p><strong>BOJ 6593 상범 빌딩 (<a href="https://www.acmicpc.net/problem/6593">문제 보기</a>)</strong></p>

<p><strong>BOJ 1486 등산 (<a href="https://www.acmicpc.net/problem/1486">문제 보기</a>)</strong></p>

<p><strong>BOJ 11657 타임머신 (<a href="https://www.acmicpc.net/problem/11657">문제 보기</a>)</strong></p>

<p><strong>BOJ 1865 웜홀 (<a href="https://www.acmicpc.net/problem/1865">문제 보기</a>)</strong></p>

<p><strong>BOJ 2606 바이러스 (<a href="https://www.acmicpc.net/problem/1865">문제 보기</a>)</strong></p>

<p><strong>BOJ 1613 역사 (<a href="https://www.acmicpc.net/problem/1613">문제 보기</a>)</strong></p>

<p><strong>BOJ 1219 오민식의 고민 (<a href="https://www.acmicpc.net/problem/1219">문제 보기</a>)</strong></p>

<h2 id="참고-자료">참고 자료</h2>

<ul>
  <li>프로그래밍 대회에서 배우는 알고리즘 문제해결전략, 구종만</li>
  <li>Competive Programming 3, Steven Halim</li>
  <li>http://codeforces.com/blog/entry/22276</li>
</ul>

</div>

<div class="share">
	<br>
    <p>Share this post with: </p>
	<a href="https://twitter.com/intent/tweet?text=최단 경로(Shortest Path)@&amp;url=http://localhost:4000/algorithm/2017/08/16/Shortest-Path.html" class="twitter-share">
		<span class="fa-stack fa-lg">
			<i class="fa fa-circle fa-stack-2x"></i>
			<i class="fa fa-twitter fa-stack-1x fa-inverse"></i>
		</span>
	</a>

	<a href="https://www.facebook.com/sharer/sharer.php?u=http://localhost:4000/algorithm/2017/08/16/Shortest-Path.html" class="facebook-share">
		<span class="fa-stack fa-lg">
			<i class="fa fa-circle fa-stack-2x"></i>
			<i class="fa fa-facebook fa-stack-1x fa-inverse"></i>
		</span>
	</a>

	<a href="https://plus.google.com/share?url=http://localhost:4000/algorithm/2017/08/16/Shortest-Path.html" class="googleplus-share">
		<span class="fa-stack fa-lg">
			<i class="fa fa-circle fa-stack-2x"></i>
			<i class="fa fa-google-plus fa-stack-1x fa-inverse"></i>
		</span>
	</a>
</div>


<div class="comments">
    
		<div id="disqus_thread"></div>
		<script>

		/**
		*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
		*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
		/*
		var disqus_config = function () {
		this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
		this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
		};
		*/
		(function() { // DON'T EDIT BELOW THIS LINE
		var d = document, s = d.createElement('script');
		s.src = 'https://museop.disqus.com/embed.js';
		s.setAttribute('data-timestamp', +new Date());
		(d.head || d.body).appendChild(s);
		})();
		</script>
		<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
                            
    
</div>



<div class="related">
  <h2>Related Posts</h2>
  <ul class="related-posts">
    
      <li>
        <h3>
          <a href="/algorithm/2017/09/12/Binary-Search.html">
            이진 탐색(Binary Search)
            <small>12 Sep 2017</small>
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/data%20structure/2017/09/12/Binary-Search-Tree.html">
            이진검색트리(Binary Search Tree)
            <small>12 Sep 2017</small>
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/data%20structure/2017/09/11/Square-Decomposition.html">
            평방 분할 기법(Square Root Decomposition)
            <small>11 Sep 2017</small>
          </a>
        </h3>
      </li>
    
  </ul>
</div>

      </div>
    </div>

    <label for="sidebar-checkbox" class="sidebar-toggle"></label>

    <script>
      (function(document) {
        var toggle = document.querySelector('.sidebar-toggle');
        var sidebar = document.querySelector('#sidebar');
        var checkbox = document.querySelector('#sidebar-checkbox');

        document.addEventListener('click', function(e) {
          var target = e.target;

          if(!checkbox.checked ||
             sidebar.contains(target) ||
             (target === checkbox || target === toggle)) return;

          checkbox.checked = false;
        }, false);
      })(document);
    </script>
  </body>
</html>
