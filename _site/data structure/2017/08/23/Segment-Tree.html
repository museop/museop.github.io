<!DOCTYPE html>
<html lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      구간 트리(Segment Tree) &middot; Pleasure of Learning
    
  </title>
  <!-- FONT -->
  <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css" rel="stylesheet" />

  <!-- CSS -->
  <link rel="stylesheet" href="/public/css/poole.css">
  <link rel="stylesheet" href="/public/css/syntax.css">
  <link rel="stylesheet" href="/public/css/lanyon.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Serif:400,400italic,700%7CPT+Sans:400">
  <link rel="stylesheet" href="/public/css/mycss.css">
  
  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/public/apple-touch-icon-precomposed.png">
  <link rel="shortcut icon" href="/public/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">
  
  <!-- MathJax -->
  
	<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
  
</head>


  <body>
  
    <!-- Target for toggling the sidebar `.sidebar-checkbox` is for regular
     styles, `#sidebar-checkbox` for behavior. -->
<input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox">

<!-- Toggleable sidebar -->
<div class="sidebar" id="sidebar">
  <div class="sidebar-item">
    <p>This Blog is using my study.</p>
  </div>

  <nav class="sidebar-nav">
    <a class="sidebar-nav-item" href="/">Home</a>

    

    
    
      
        
      
    
      
        
      
    
      
        
          <a class="sidebar-nav-item" href="/about.html">About</a>
        
      
    
      
        
          <a class="sidebar-nav-item" href="/archive.html">Archive</a>
        
      
    
      
    
      
        
          <a class="sidebar-nav-item" href="/category.html">Category</a>
        
      
    
      
        
      
    
      
        
      
    
      
        
          <a class="sidebar-nav-item" href="/tags.html">Tags</a>
        
      
    
<!--
    <a class="sidebar-nav-item" href="/archive/v1.0.1.zip">Download</a>
    <a class="sidebar-nav-item" href="">GitHub project</a>
    <span class="sidebar-nav-item">Currently v1.0.1</span> -->
  </nav>

  <div class="sidebar-item">
    <p>
      &copy; 2018. All rights reserved.
    </p>
  </div>
</div>


    <!-- Wrap is the content to shift when toggling the sidebar. We wrap the
         content to avoid any CSS collisions with our real content. -->
    <div class="wrap">
      <div class="masthead">
        <div class="container">
          <h3 class="masthead-title">
            <a href="/" title="Home">Pleasure of Learning</a>
            <small></small>
          </h3>
        </div>
      </div>

      <div class="container content">
        <div class="post">
  <h1 class="post-title">구간 트리(Segment Tree)</h1>
  <span class="post-date"><time>23 Aug 2017</time></span>
  <div class="post-tags">
      
        <a class="post-tags-item" href="http://localhost:4000/tags#tree">
          <span>tree</span>
        </a>
      
        <a class="post-tags-item" href="http://localhost:4000/tags#segment tree">
          <span>segment tree</span>
        </a>
      
  </div>

  <h2 id="구간-트리란">구간 트리란?</h2>

<p>구간 트리(segment tree)는 일차원 배열의 특정 구간에 대한 질문(query)을 빠르게 답하는데 사용할 수 있는 자료 구조이다. 예를 들어 배열 A = { 1, 3, 4, 2, 3, 1, 7 }와 같은 배열에서 구간 a[2..5]의 합을 빠르게 구한다거나 A[1..4] 중 최솟값, 최댓값을 빠르게 구하는 등 다양한 용도로 사용할 수 있다.</p>

<p>구간 트리는 이진 트리 형태로 구성되고, 각 트리의 노드가 일차원 배열의 특정 구간을 대표하게 된다. 배열 a[10]이 있다면 아래 그림과 같이 구간 트리를 구성할 수 있다.</p>

<p><img src="http://localhost:4000/assets/segment-tree.png" alt="segment-tree" /></p>

<p>이와 같은 구간 트리는 배열 A에 대하여, 다음과 같은 작업을 반복적으로 수행할 때, 효율적으로 사용할 수 있는 자료구조가 된다.</p>

<ol>
  <li>특정 구간 A[l..r]의 합(또는 최댓값, 최솟값 등)을 구하는 작업</li>
  <li>A[k]번째 수를 변경하는 작업</li>
</ol>

<p>구간 합 트리는 아래와 같이 구현할 수 있다. 구간 최대, 최소 트리도 원리는 같기 때문에 구현하기 어렵지 않다.</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">struct</span> <span class="n">SegmentTree</span> <span class="p">{</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">tree</span><span class="p">;</span>

  <span class="n">SegmentTree</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">arr</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">//assert(!arr.empty());
</span>    <span class="n">tree</span><span class="p">.</span><span class="n">assign</span><span class="p">(</span><span class="n">arr</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">*</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">build</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">arr</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">build</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">arr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">l</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">l</span> <span class="o">==</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">tree</span><span class="p">[</span><span class="n">id</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">l</span><span class="p">];</span>
      <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="n">r</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
    <span class="n">build</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">id</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">m</span><span class="p">);</span>
    <span class="n">build</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">id</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
    <span class="n">tree</span><span class="p">[</span><span class="n">id</span><span class="p">]</span> <span class="o">=</span> <span class="n">tree</span><span class="p">[</span><span class="n">id</span><span class="o">*</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">tree</span><span class="p">[</span><span class="n">id</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">update</span><span class="p">(</span><span class="kt">int</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">int</span> <span class="n">diff</span><span class="p">,</span> <span class="kt">int</span> <span class="n">id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">l</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">&lt;</span> <span class="n">l</span> <span class="o">||</span> <span class="n">pos</span> <span class="o">&gt;</span> <span class="n">r</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">l</span> <span class="o">==</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">tree</span><span class="p">[</span><span class="n">id</span><span class="p">]</span> <span class="o">+=</span> <span class="n">diff</span><span class="p">;</span>
      <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="n">r</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
    <span class="n">update</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">diff</span><span class="p">,</span> <span class="n">id</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">m</span><span class="p">);</span>
    <span class="n">update</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">diff</span><span class="p">,</span> <span class="n">id</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
    <span class="n">tree</span><span class="p">[</span><span class="n">id</span><span class="p">]</span> <span class="o">=</span> <span class="n">tree</span><span class="p">[</span><span class="n">id</span><span class="o">*</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">tree</span><span class="p">[</span><span class="n">id</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
  <span class="p">}</span>

  <span class="kt">int</span> <span class="n">query</span><span class="p">(</span><span class="kt">int</span> <span class="n">ql</span><span class="p">,</span> <span class="kt">int</span> <span class="n">qr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">l</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ql</span> <span class="o">&gt;</span> <span class="n">r</span> <span class="o">||</span> <span class="n">qr</span> <span class="o">&lt;</span> <span class="n">l</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ql</span> <span class="o">&lt;=</span> <span class="n">l</span> <span class="o">&amp;&amp;</span> <span class="n">r</span> <span class="o">&lt;=</span> <span class="n">qr</span><span class="p">)</span> <span class="k">return</span> <span class="n">tree</span><span class="p">[</span><span class="n">id</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="n">r</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">query</span><span class="p">(</span><span class="n">ql</span><span class="p">,</span> <span class="n">qr</span><span class="p">,</span> <span class="n">id</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
         <span class="o">+</span> <span class="n">query</span><span class="p">(</span><span class="n">ql</span><span class="p">,</span> <span class="n">qr</span><span class="p">,</span> <span class="n">id</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">};</span>
</code></pre>
</div>

<h2 id="lazy-propagation">Lazy Propagation</h2>

<p>기본적인 구간 트리의 구현에서는 특정 구간의 값을 일정하게 변경할 때 트리의 루트부터 말단 노드까지 타고 내려가 해당하는 말단 노드들의 값을 모두 변경하는 방식을 사용한다. 예를 들어 [l..r] 구간의 값들에 3씩 더하려면 위에서 구현한 코드로는 update(l, 3), update(l+1, 3), …, update(r-1, 3), update(r, 3)을 해주어야 한다. 구현을 조금 다르게 해서 한 번의 호출로 [l..r] 구간을 모두 업데이트하게 만들어 조금 빠르게 만들 수도 있겠지만 결국 트리의 말단 노드까지 모두 내려가야 하므로 이러한 연산의 시간복잡도는 <script type="math/tex">O(nlog_2n)</script>이 된다. 이와 같은 방식이 이해하기 쉽지만, 너무 느리다는 단점이 있다.</p>

<p>구간 트리의 각 노드는 특정 구간의 값들을 대표한다. 어떤 구간의 값들을 갱신하려고 할 때, 일단 해당 구간을 대표하는 노드의 값만 갱신하고, 이 노드의 자식 노드들은 나중에 갱신이 꼭 필요할 때 해주면 이 작업을 보다 빠르게 수행할 수 있다. 아래 코드와 같이 각 노드에 대해 갱신에 필요한 정보를 저장하는 정보를 저장해두면 이와 같은 작업을 비교적 간결하게 구현하게 있다.</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">struct</span> <span class="n">SegmentTreeLazyPropagation</span> <span class="p">{</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">tree</span><span class="p">,</span> <span class="n">lazy</span><span class="p">;</span>

  <span class="n">SegmentTreeLazyPropagation</span><span class="p">(</span><span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">arr</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">//assert(!arr.empty());
</span>    <span class="n">tree</span><span class="p">.</span><span class="n">assign</span><span class="p">(</span><span class="n">arr</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">*</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">lazy</span><span class="p">.</span><span class="n">assign</span><span class="p">(</span><span class="n">arr</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">*</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">build</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">arr</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">build</span><span class="p">(</span><span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">arr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">l</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">l</span> <span class="o">==</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">tree</span><span class="p">[</span><span class="n">id</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">l</span><span class="p">];</span>
      <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="n">r</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
    <span class="n">build</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">id</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">m</span><span class="p">);</span>
    <span class="n">build</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">id</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
    <span class="n">tree</span><span class="p">[</span><span class="n">id</span><span class="p">]</span> <span class="o">=</span> <span class="n">tree</span><span class="p">[</span><span class="n">id</span><span class="o">*</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">tree</span><span class="p">[</span><span class="n">id</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">propagate</span><span class="p">(</span><span class="kt">int</span> <span class="n">id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">l</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">lazy</span><span class="p">[</span><span class="n">id</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">tree</span><span class="p">[</span><span class="n">id</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span><span class="n">r</span> <span class="o">-</span> <span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">lazy</span><span class="p">[</span><span class="n">id</span><span class="p">];</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">l</span> <span class="o">!=</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">lazy</span><span class="p">[</span><span class="n">id</span><span class="o">*</span><span class="mi">2</span><span class="p">]</span> <span class="o">+=</span> <span class="n">lazy</span><span class="p">[</span><span class="n">id</span><span class="p">];</span>
        <span class="n">lazy</span><span class="p">[</span><span class="n">id</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">lazy</span><span class="p">[</span><span class="n">id</span><span class="p">];</span>
      <span class="p">}</span>
      <span class="n">lazy</span><span class="p">[</span><span class="n">id</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">update_range</span><span class="p">(</span><span class="kt">int</span> <span class="n">ul</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ur</span><span class="p">,</span> <span class="kt">int</span> <span class="n">diff</span><span class="p">,</span> <span class="kt">int</span> <span class="n">id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">l</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">propagate</span><span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span> 
    <span class="k">if</span> <span class="p">(</span><span class="n">ul</span> <span class="o">&gt;</span> <span class="n">r</span> <span class="o">||</span> <span class="n">ur</span> <span class="o">&lt;</span> <span class="n">l</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ul</span> <span class="o">&lt;=</span> <span class="n">l</span> <span class="o">&amp;&amp;</span> <span class="n">r</span> <span class="o">&lt;=</span> <span class="n">ur</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">tree</span><span class="p">[</span><span class="n">id</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span><span class="n">r</span> <span class="o">-</span> <span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">diff</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">l</span> <span class="o">!=</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">lazy</span><span class="p">[</span><span class="n">id</span><span class="o">*</span><span class="mi">2</span><span class="p">]</span> <span class="o">+=</span> <span class="n">diff</span><span class="p">;</span>
        <span class="n">lazy</span><span class="p">[</span><span class="n">id</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">diff</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="n">r</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
    <span class="n">update_range</span><span class="p">(</span><span class="n">ul</span><span class="p">,</span> <span class="n">ur</span><span class="p">,</span> <span class="n">diff</span><span class="p">,</span> <span class="n">id</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">m</span><span class="p">);</span>
    <span class="n">update_range</span><span class="p">(</span><span class="n">ul</span><span class="p">,</span> <span class="n">ur</span><span class="p">,</span> <span class="n">diff</span><span class="p">,</span> <span class="n">id</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
    <span class="n">tree</span><span class="p">[</span><span class="n">id</span><span class="p">]</span> <span class="o">=</span> <span class="n">tree</span><span class="p">[</span><span class="n">id</span><span class="o">*</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">tree</span><span class="p">[</span><span class="n">id</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
  <span class="p">}</span>

  <span class="kt">int</span> <span class="n">query</span><span class="p">(</span><span class="kt">int</span> <span class="n">ql</span><span class="p">,</span> <span class="kt">int</span> <span class="n">qr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">l</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">propagate</span><span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ql</span> <span class="o">&gt;</span> <span class="n">r</span> <span class="o">||</span> <span class="n">qr</span> <span class="o">&lt;</span> <span class="n">l</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ql</span> <span class="o">&lt;=</span> <span class="n">l</span> <span class="o">&amp;&amp;</span> <span class="n">r</span> <span class="o">&lt;=</span> <span class="n">qr</span><span class="p">)</span> <span class="k">return</span> <span class="n">tree</span><span class="p">[</span><span class="n">id</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="n">r</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">query</span><span class="p">(</span><span class="n">ql</span><span class="p">,</span> <span class="n">qr</span><span class="p">,</span> <span class="n">id</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
         <span class="o">+</span> <span class="n">query</span><span class="p">(</span><span class="n">ql</span><span class="p">,</span> <span class="n">qr</span><span class="p">,</span> <span class="n">id</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">};</span>
</code></pre>
</div>

<h2 id="연습-문제">연습 문제</h2>

<h3 id="rsq">RSQ</h3>

<h4 id="boj-4297-ultra-quick-sort-문제-보기">BOJ 4297 Ultra-Quick Sort (<a href="https://www.acmicpc.net/problem/4297">문제 보기</a>)</h4>

<p>역전의 수(Inversion)의 수를 세는 문제로  0번 원소부터 N-1번 원소까지 각 원소를 구간 트리에 1로 업데이트 해주는데, 이 때 i 번 원소는 [ 0 ~ i-1 ] 번 원소들 중 자신보다 큰 원소의 수를 구간 합 트리를 이용하여  셀 수 있다.</p>

<h4 id="boj-13334-철로-문제-보기">BOJ 13334 철로 (<a href="https://www.acmicpc.net/problem/13334">문제 보기</a>)</h4>

<p>모든 철로의 시작과 끝 x 좌표들을 압축한 배열  <strong>X</strong>와 이에 대응하는 구간 합 트리를 만들고, 각 철로의 끝 지점에서 철로의 시작 지점에 해당하는 <strong>X</strong> 배열 위치에 1로 업데이트 해주고, (끝 지점 - L, 끝 지점)에 해당하는 구간에 쿼리를 날려 이 구간에 포함되는 철로의 수를 세면 된다.</p>

<h4 id="boj-3653-영화-수집문제-보기">BOJ 3653 영화 수집(<a href="https://www.acmicpc.net/problem/3653">문제 보기</a>)</h4>

<p>m+n개 원소의 구간 합을 저장하는 구간 합 트리를 만든다. 그리고 [m ~ m+n-1] 번 원소의 값을 1 (존재함을 의미)로 만들어 준다. 그리고 어떤 DVD x 를 뺄 때, 이 x 의 구간 트리 상의 위치를 R 이라고 하면 R의 값을 0으로 업데이트 해주고 구간 (0, R-1) 의 합을 쿼리를 통해 x의 위에 있는 DVD의 총 수를 구할 수 있다.</p>

<h4 id="boj-1280-나무-심기-문제-보기">BOJ 1280 나무 심기 (<a href="https://www.acmicpc.net/problem/1280">문제 보기</a>)</h4>

<p>구간 합 트리를 두 개 사용하면 된다. 하나는 단순히 해당 좌표에 나무가 몇 개 있는지를 저장하는 구간 트리 <strong>cTree</strong>, 다른 하나는 x = 0 에서부터 해당 위치까지 거리, 즉 x = 1 에는 1, x = 3 에는 3,  x = X[i] 에는 X[i]를 저장하는 구간 트리 <strong>sTree</strong>. 그러면 나무를 X[i] 에 심는데 필요한 비용(현재 심어져있는 모든 나무 까지 거리의 합)은 <strong>lcnt</strong> <script type="math/tex">\times X[i]</script> - <strong>lsum</strong> 과 <strong>rsum</strong>  - <strong>rcnt</strong> <script type="math/tex">\times X[i]</script> 을 합해서 얻을 수 있다. 여기서 <strong>lcnt, rcnt, lsum, rsum</strong>이 의미하는 바는 다음과 같다.</p>

<ul>
  <li><strong>lcnt</strong>: <strong>cTree</strong> 에 구간 [0 , X[i] - 1] 쿼리 결과, 즉 왼쪽에 심어져 있는 나무의 개수</li>
  <li><strong>rcnt</strong>: <strong>cTree</strong> 에 구간 [X[i]+1, MAX_X] 쿼리 결과, 즉 오른쪽에 심어져 있는 나무의 개수</li>
  <li><strong>lsum</strong>: <strong>sTree</strong> 에 구간 [0, X[i] - 1] 쿼리 결과, 즉 x = 0부터 왼쪽에 심어져 있는 나무들까지의 거리 총합</li>
  <li><strong>rsum</strong>: <strong>sTree</strong> 에 구간 [X[i]+1, MAX_X] 쿼리 결과, 즉 x = 0 부터 왼쪽에 심어져 있는 나무들까지의 거리 총합</li>
</ul>

<h4 id="boj-1655-가운데를-말해요-문제-보기">BOJ 1655 가운데를 말해요 (<a href="https://www.acmicpc.net/problem/1655">문제 보기</a>)</h4>

<p>특정 원소가 있으면 1로, 없으면 0으로 배열에 대응하는 구간 합 트리를 이용하면  k 번째 원소를 찾을 수 있다.</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">kth</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span><span class="p">,</span> <span class="kt">int</span> <span class="n">id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">l</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">l</span> <span class="o">==</span> <span class="n">r</span><span class="p">)</span> <span class="k">return</span> <span class="n">l</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="n">r</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">tree</span><span class="p">[</span><span class="n">id</span><span class="o">*</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">k</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">kth</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">id</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">m</span><span class="p">);</span>
  <span class="k">else</span>
    <span class="k">return</span> <span class="n">kth</span><span class="p">(</span><span class="n">k</span><span class="o">-</span><span class="n">tree</span><span class="p">[</span><span class="n">id</span><span class="o">*</span><span class="mi">2</span><span class="p">],</span> <span class="n">id</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
</div>

<h3 id="rmq">RMQ</h3>

<p><strong>BOJ 1753 최단경로 (<a href="https://www.acmicpc.net/problem/1753">문제 보기</a>)</strong></p>

<p>간단하게 다익스트라로 풀 수 있는 문제인데, 다익스트라를 구간 트리로 구현할 수 있다. 우선순위큐에서 최단거리로 갈 수 있는 정점을 꺼내는 작업을 구간 최소 트리로 구현할 수 있다. 이미 최단 거리를 구한 정점은 트리에 INF로 업데이트해주면 된다.</p>

<p><strong>BOJ 5480 전함 (<a href="https://www.acmicpc.net/problem/5480">문제 보기</a>)</strong></p>

<p>모든 전함의 시작, 끝 x 좌표와 수직으로 발사하는 레이저의 x 좌표로 구성된 <strong>X</strong> 배열과 이에 대응하는 구간 최소 트리 <strong>xTree</strong> 를 만들고,  마찬가지로 모든 전함의 y 좌표와 수평으로 발사하는 레이저의 y 좌표로 구성된 <strong>Y</strong> 배열과 이에 대응하는 구간 최소 트리 <strong>yTree</strong> 를 만든다.</p>

<p>그리고 각 수직, 수평 레이저의 배열 <strong>X, Y</strong> 위치에 레이저 번호 (빨리 발사되는 레이저일 수록 작은 번호)로 값을 갱신해준다. 이 때, 같은 위치에서 같은 방향으로 발사하는 레이저는 먼저 발사된 레이저의 값으로 해주어야 한다. 그런 다음에는 각 전함의 시작 x 좌표, 끝 x 좌표로 구간 트리  <strong>xTree</strong> 에 쿼리를 날리고, 마찬가지로 시작 y 좌표, 끝 y 좌표로 구간 트리 <strong>yTree</strong> 에 쿼리를 날리면 자신을 파괴하는 레이저를 찾아 낼 수 있다.</p>

<p><strong>BOJ 3745 오름세 (<a href="https://www.acmicpc.net/problem/3745">문제 보기</a>)</strong></p>

<p><strong>lis</strong> 를 찾는 문제이다. 0 번 원소부터 N-1 번 원소까지 순회하면서 자신을 끝으로 하여 만들 수 있는 최대 <strong>lis</strong> 의 길이를 구간 트리에 업데이트 해준다. 이 때 i 번 원소는 [0 ~ i-1 ] 번 원소들 중 자신보다 작은 원소를 끝으로 하는 최대  최대  <strong>lis</strong> 의 길이를 구간 최대 트리로 찾을 수 있다.</p>

<p><strong>BOJ 1365 꼬인 전깃줄 (<a href="https://www.acmicpc.net/problem/1365">문제 보기</a>)</strong></p>

<p>전깃줄을 꼬이지 않게 줄들을 선택해 나가기 위해서는 좌측 1번부터 이에 대응하는 우측 전봇대를 항상 오름차순으로 선택해 나가면 된다. 즉 <strong>lis</strong> 를 구하는 문제와 같아진다. 위의 오름세 문제와 같은 방식으로 풀면 된다.</p>

<p><strong>BOJ 9345 디지털 비디오 디스크(DVDs) (<a href="https://www.acmicpc.net/problem/9345">문제 보기</a>)</strong></p>

<p>L번 선반부터 R번 선반까지 L번 DVD부터 R번 DVD까지 모두 있는지는 구간 (L, R) 의 최솟값이 L이고, 구간 (L, R) 의 최댓값이 R 인지를 확인하면 알 수 있다.</p>

<h3 id="lazy-propagation-1">Lazy propagation</h3>

<p><strong>BOJ 2934 LRH 식물 (<a href="https://www.acmicpc.net/problem/2934">문제 보기</a>)</strong></p>

<p>먼저 가능한 모든 x 좌표로 구간 합 트리를 만든다. 매일 매일 나무를 심는 작업은  [L+1, R-1]  구간의 값을 모두 1로 만들면 되고, 꽃이 몇 개 피는지는 L 과 R 의 쿼리를 날려 얻을 수 있다. 꽃이 핀 부분은 다시 0으로 업데이트 해주면 된다. 구간 값 갱신을 <script type="math/tex">O(log_2N)</script>에 수행하는 Lazy propagation 구간 합 트리 구현이 필요한 문제이다.  또는 펜윅 트리를 사용하면 보다 쉽게 구현이 가능하다.</p>

<p><strong>BOJ 1395 스위치 (<a href="https://www.acmicpc.net/problem/1395">문제 보기</a>)</strong></p>

<p><strong>BOJ 12844 XOR (<a href="https://www.acmicpc.net/problem/12844">문제 보기</a>)</strong></p>

<p><strong>BOJ 7626 직사각형 (<a href="https://www.acmicpc.net/problem/7626">문제 보기</a>)</strong></p>

<h2 id="참고-자료">참고 자료</h2>

<ul>
  <li>프로그래밍 대회에서 배우는 알고리즘 문제해결전략, 구종만</li>
  <li>Competive Programming 3, Steven Halim</li>
  <li><a href="https://www.acmicpc.net/blog/view/9">https://www.acmicpc.net/blog/view/9</a></li>
  <li><a href="https://www.acmicpc.net/blog/view/26">https://www.acmicpc.net/blog/view/26</a></li>
</ul>


</div>

<div class="share">
	<br>
    <p>Share this post with: </p>
	<a href="https://twitter.com/intent/tweet?text=구간 트리(Segment Tree)@&amp;url=http://localhost:4000/data%20structure/2017/08/23/Segment-Tree.html" class="twitter-share">
		<span class="fa-stack fa-lg">
			<i class="fa fa-circle fa-stack-2x"></i>
			<i class="fa fa-twitter fa-stack-1x fa-inverse"></i>
		</span>
	</a>

	<a href="https://www.facebook.com/sharer/sharer.php?u=http://localhost:4000/data%20structure/2017/08/23/Segment-Tree.html" class="facebook-share">
		<span class="fa-stack fa-lg">
			<i class="fa fa-circle fa-stack-2x"></i>
			<i class="fa fa-facebook fa-stack-1x fa-inverse"></i>
		</span>
	</a>

	<a href="https://plus.google.com/share?url=http://localhost:4000/data%20structure/2017/08/23/Segment-Tree.html" class="googleplus-share">
		<span class="fa-stack fa-lg">
			<i class="fa fa-circle fa-stack-2x"></i>
			<i class="fa fa-google-plus fa-stack-1x fa-inverse"></i>
		</span>
	</a>
</div>


<div class="comments">
    
		<div id="disqus_thread"></div>
		<script>

		/**
		*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
		*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
		/*
		var disqus_config = function () {
		this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
		this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
		};
		*/
		(function() { // DON'T EDIT BELOW THIS LINE
		var d = document, s = d.createElement('script');
		s.src = 'https://museop.disqus.com/embed.js';
		s.setAttribute('data-timestamp', +new Date());
		(d.head || d.body).appendChild(s);
		})();
		</script>
		<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
                            
    
</div>



<div class="related">
  <h2>Related Posts</h2>
  <ul class="related-posts">
    
      <li>
        <h3>
          <a href="/algorithm/2017/09/12/Binary-Search.html">
            이진 탐색(Binary Search)
            <small>12 Sep 2017</small>
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/data%20structure/2017/09/12/Binary-Search-Tree.html">
            이진검색트리(Binary Search Tree)
            <small>12 Sep 2017</small>
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/data%20structure/2017/09/11/Square-Decomposition.html">
            평방 분할 기법(Square Root Decomposition)
            <small>11 Sep 2017</small>
          </a>
        </h3>
      </li>
    
  </ul>
</div>

      </div>
    </div>

    <label for="sidebar-checkbox" class="sidebar-toggle"></label>

    <script>
      (function(document) {
        var toggle = document.querySelector('.sidebar-toggle');
        var sidebar = document.querySelector('#sidebar');
        var checkbox = document.querySelector('#sidebar-checkbox');

        document.addEventListener('click', function(e) {
          var target = e.target;

          if(!checkbox.checked ||
             sidebar.contains(target) ||
             (target === checkbox || target === toggle)) return;

          checkbox.checked = false;
        }, false);
      })(document);
    </script>
  </body>
</html>
