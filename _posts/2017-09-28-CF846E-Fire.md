---
layout: post
title: Codeforces 864E Fire
comments: true
tags: [problem solving, codeforces, dynamic programming, greedy]
eye_catch: http://st.codeforces.com/s/61270/images/codeforces-logo-with-telegram.png
---

[문제 보기](http://codeforces.com/contest/864/problem/E)

## 문제 요약

$$n$$개의 물품 목록이 주어지는데, 각 물품은 다음과 같은 값들을 가진다.

- $$t_i$$: $$i$$번째 물품을 구하는데 소요되는 시간
- $$d_i$$: $$i$$번째 물품의 가치가 유효한 시간, 즉 가치를 지켜내기 위해 구해내야만 하는 시간
- $$p_i$$: $$i$$번째 물품의 가치

어떤 순서로 어떤 물품들을 구하는지에 따라 물품들을 구해서 얻은 가치의 합이 달라진다. 이때, 가능한 가장 큰 총합을 구하는 문제다.

## 풀이

가장 단순한 방법은 가능한 모든 경우를 따져보는 것이다. 모든 경우를 다 따져볼 경우 각각의 물품을 구할지 말지를 정해야 하고, 해당 물품들을 어떤 순서로 구해야 하는지 따져봐야 하므로 시간복잡도는 $$O(2^n \times n!)$$이다. 문제에서 주어진 최대 $$n$$의 크기를 고려하면 너무 느린 방법이다.

가치의 합이 최대가 되도록 하는 최적의 답이 어떤 형태일지 고민해보면 풀이에 대한 힌트를 얻을 수 있다. 답이 아래와 같다고 해보자(여기서 $$p, q, r, s$$는 몇 번째 물품인지를 나타낸다고 하자).

$$p$$, ..., $$q$$, $$r$$, ..., $$s$$

여기서 $$d_q \gt d_r$$라고 해보자, 즉 $$q$$번째 물품의 가치가 유효한 시간이 $$r$$번째 물품의 시간보다 더 긴 경우다. 이 경우 두 물품의 순서를 바꾼다고 하더라도 가치의 합이 더 나빠지지 않음을 확인할 수 있다. 따라서 인접한 두 물품들의 순서를 $$d_i$$값이 작은 물품이 앞쪽에 오도록 정렬하더라도 최적해를 구할 수 있다. 어떤 순서대로 물품들을 골라야 하는지 정해지면 문제는 쉬워진다. 아래와 같이 부분 문제를 정의해 볼 수 있다.

```
dp[i][ct]: 현재 시간이 ct일 때, i~n번째 물품에서 얻을 수 있는 최대 가치 합
```

위와 같은 부분 문제는 $$i$$번째 물품을 구하느냐 마느냐에 따라 최대 가치 합이 달라진다. 따라서 선택에 따라 필요한 다음 부분 문제들과의 관계를 세우면 문제를 해결할 수 있다.

구체적인 관계식은 아래 코드에서 확인할 수 있다. 알고리즘의 시간복잡도는 $$O(n \times T)$$이다. 여기서 $$T$$는 부분 문제에서 가능한 최대 시간이다. 가능한 최대 $$t$$값에 $$n$$을 곱한 값이라 볼 수 있다.

[코드 보기](https://github.com/robustFlame/problem_solving/blob/master/Codeforces/436E.cpp)

[출제자 해설 보기](http://codeforces.com/blog/entry/54765)