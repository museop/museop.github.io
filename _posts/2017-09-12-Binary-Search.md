---
layout: post
title: 검색 알고리즘(Searching Algorithm)
comments: true
category: algorithm
tag: [search, binary search, tree, binary search tree]
---
* list element with functor item
{:toc}

# 1. 개념

검색이란 여러 자료들로 이루어진 특정 자료 구조에서 주어진 키(key)에 해당하는 자료를 찾아내는 것을 말한다. 검색 알고리즘은 정렬 알고리즘과 함께 많은 프로그램, 알고리즘에서 필수 요소로 사용되기 때문에 가장 많이 연구된 알고리즘이다. 프로그래머라면 여러 유명한 검색 알고리즘들에 대해서 잘 숙지하고 활용할 수 있어야 한다.

비교적 유명한 검색 알고리즘으로는 Linear Search, Binary Search, Jump Search, Interpolation Search, Exponential Search, Ternary Search 등이 있는데 이 글에서는 PS에서 반드시 숙지하고 있어야할 검색 알고리즘인 이분 검색(Binary Search)에 관한 내용을 중점적으로 다루었다.



## 이분 검색(Binary Search)

이분 검색은 이미 정렬된 자료에서 분할 정복 전략을 이용하여 $$O(log_2n)$$ 검색 시간을 갖는 매우 빠른 알고리즘이다. 자료의 집합이 특정 키(key)값을 기준으로 (오름차순으로) 정렬되어 있다고 하자. 이분 검색은 자료의 중간 위치 값과 찾고자 하는 키(key)값을 비교한다. 만약 키 값이 더 작다면 왼쪽 자료 집합에서 같은 방식으로 재귀적으로 답을 찾고, 더 크다면 오른쪽 자료 집합에서 답을 찾아가는 전략을 취한다.

오름차순으로 정렬된 일차원 배열에서 특정 키 값을 찾는 이분 검색을 아래와 같이 구현할 수 있다.

```c++
int binary_search(int arr[], int n, int key) {
  int l = 0, r = n - 1;
  while (l <= r) {
    int mid = l + (r - l) / 2;
    if (arr[mid] == key) return mid;
    if (key < arr[mid])
      r = mid - 1;
    else
      l = mid + 1;
  }
  return -1; // not found
}
```



이분 검색은 워낙 많이 사용되는 검색 알고리즘이기 때문에 많은 언어에서 라이브러리로 제공하고 있다. 그 중 C++ STL에서는 다음과 같은 함수들을 제공한다. 간결한 코딩을 위해 익숙하게 사용하는 것이 좋다.

- `std::binary_search`: 정렬된 순차열에서 특정 값이 존재하는지 판단한다.
- `std::lower_bound`: 정렬된 순차열에서 특정 값보다 작지 않은 첫 원소의 위치(iterator)를 반환한다.
- `std::upper_bound`: 정렬된 순차열에서 특정 값보다 큰 첫 원소의 위치(iterator)를 반환한다.
- `std::equal_range`:  정렬된 순차열에서 특정 값이 포함되는 범위 [first, last)를 반환한다(`lower_bound`와 `upper_bound`의 쌍(pair)을 반환한다).





## 이진 트리 검색(Binary Tree Search)

자료 집합에서 이분 검색을 수행할 수 있게 하려면 자료들이 정렬되어 있어야 한다. 매번 정렬을 한 후 이분 검색을 할 수는 없기 때문에 자료의 삽입, 삭제 작업 이후에도 자료가 정렬되어 있도록 유지해야 한다. 배열에서 이분 검색은 $$O(log_2n)$$에 수행되지만 원소의 삭제, 삽입 과정은 자료를 정렬되게 유지하게 위해 평균 $$n/2$$개의 자료를 밀거나 당기는 작업이 필요하여 $$O(n)$$의 수행 시간을 갖는다. 따라서 이분 검색은 삽입, 삭제가 정적인 자료 구조에 적합한 방식이다. 만약 자료의 삽입, 삭제가 빈번하게 이루어지는 경우 이진 트리 검색을 사용하는 것이 좋다.

### 이진 검색 트리(Binary Search Tree)

이진 트리 검색은 동적인 자료 구조인 이진 검색 트리(Binary Search Tree, 이하 BST)를 이용하여 자료를 검색한다. 이진 검색 트리는 다음과 같은 속성을 유지하는 트리다.

- 각 노드의 키(key) 값은 유일하다.
- 키 값들의 순서가 존재한다.
- 각 노드는 왼쪽, 오른쪽 두 자식 노드를 갖는다.
- 노드의 왼쪽 자식 노드를 루트로 하는 서브 트리에는 그 노드의 값보다 작은 값들을 갖는 노드들로 이루어져 있다.
- 노드의 오른쪽 자식 노드를 루트로 하는 서브 트리에는 그 노드의 값보다 큰 값들을 갖는 노드들로 이루어져 있다.

이진 트리는 그 구조상 이분 검색과 거의 유사하게 자료를 찾기 때문에 검색 속도가 매우 빠르다. 트리의 높이를 $$h$$라고 했을 때 $$O(h)$$의 시간복잡도를 갖는다. 트리가 균형 잡혀 있다면 $$h=log_2n$$이므로  $$O(log_2n)$$의 검색 시간을 갖는다. 이진 검색 트리에서의 **검색**은 다음과 같이 이루어진다.

```
1. 키값이 현재 노드의 값과 같으면 현재 노드를 반환한다(만약 현재 노드가 없다면(NULL), 해당 키 값은 존재하지 않는다).
2. 키값이 현재 노드의 값보다 작으면 왼쪽 서브 트리에서 재귀적으로 검색한다.
3. 키값이 현재 노드의 값보다 크면 오른쪽 서브 트리에서 재귀적으로 검색한다.
```

이진 검색 트리에 새로운 자료를 **삽입**하는 과정은 검색 과정과 유사하다. 이진 검색 트리의 루트 노드부터 삽입할 노드의 키 값과 비교하면서 삽입할 위치를 찾다보면 말단 노드에 이르게 된다. 말단 노드와 키 값을 비교하여 말단 노드의 왼쪽 또는 오른쪽에 삽입하면 된다. (시간복잡도는 $$O(h)$$)

이진 검색 트리에서의 **삭제** 작업은 검색을 통하여 삭제할 노드를 찾는 것부터 시작한다. 삭제할 노드를 찾고나면 삭제할 노드의 자식 수에 따라 다음 세 가지 경우로 나누어진다.  (시간복잡도는 $$O(h)$$)

- 자식 노드가 없는 경우: 해당 노드를 삭제한 후, 부모 노드와의 연을 끊으면 된다.
- 자식 노드가 1개인 경우: 해당 노드를 삭제하고, 그 위치에 자식 노드를 세우면 된다.
- 자식 노드가 2개인 경우: 해당 노드의 노드를 삭제하고, 그 위치에 해당 노드의 왼쪽 서브 트리에서 가장 큰 노드 또는 오른쪽 서브 트리에서 가장 작은 노드를 떼어다가 놓으면 된다.





### 균형잡힌 검색 트리(Balanced Search Tree)

이진 검색 트리의 단점은 자료의 입력 순서에 따라 트리의 높이 $$h$$가 달라진다는 것이다. 검색, 삽입, 삭제 연산 모두 $$h$$에 의해 수행 속도가 영향을 받기 때문에 트리의 높이를 낮게 만드는 것이 중요하다. 트리의 높이가 낮으려면 트리의 모양이 균형이 잡혀있어야 한다. 때문에 삽입, 삭제 과정에서 트리가 균형 잡히도록 하는 많은 연구가 진행되었고, 균형 잡힌 트리로 알려진 대표적인 자료 구조들로는 AVL tree, Red-black tree, Splay tree, Treap 등이 있다.

C++ STL에서는 `std::set, set::map, set::multiest, set::multimap`등의 균형잡힌 검색 트리(Red-black tree로 구현되었다고 한다)를 제공한다. 이러한 라이브러리를 이용하여 검색, 삽입, 삭제 과정을 모두 $$O(log_2n)$$에 수행할 수 있다. 다만, 위 라이브러리들은 기초적인 연산(검색, 삽입, 삭제)만 제공하므로 $$k$$번째 원소를 찾는 것과 같이 좀 더 추가적인 연산을 필요로 한다면 직접 균형잡힌 검색 트리를 구현해야 한다. AVL tree나 Red-black tree의 경우 다소 복잡하기 때문에 시간이 촉박한 프로그래밍 대회에서 구현하기에는 부적합하고 대신 그보다 비교적 간결한 Splay tree나 Treap을 구현하여 사용하는 것이 좋다.

#### Treap

추가 예정

#### Splay Tree

추가 예정



## 다른 검색 알고리즘들

### Linear Search

### Jump Search

### Interpolation Search

### Exponential Search

### Ternary Search

<br>

# 2. 연습 문제

<br>

# 3. 참고 자료



