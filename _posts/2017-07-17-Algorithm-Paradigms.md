---
layout: post
title: 알고리즘 설계 패러다임 (Algorithm Paradigms)
comments: true
category: problem solving
tag: [complete search, divide and conquer, greedy, dynamic programming]
---
* list element with functor item
{:toc}
## (1) 완전 탐색 (Complete Search)

### 1.1 완전 탐색이란?

완전 탐색은 답이 될 수도 있는 모든 경우를 만들어보면서 답을 찾는 방법을 말한다. 모든 경우를 다 고려해본 후 결론(답)에 이르기 때문에 속도가 매우 느리다. 하지만 완전 탐색은 답의 구조나 패턴을 파악하는데 도움을 주어 더 좋은 알고리즘을 설계하는데 도움을 줄 수도 있고, 다른 알고리즘이 작은 입력에서 정확하게 동작하는지 검증하는 용도로도 사용할 수 있다.

완전 탐색은 보통 반복문 또는 재귀 함수로 구현한다. 일반적으로 반복문으로 작성하는 것이 속도면에서 유리하겠지만, 다양한 형태의 문제를 보다 간결하게 구현하는데에는 재귀 함수가 낫다.

### 1.2 예제

#### BOJ 2309 일곱 난쟁이 ([문제 보기](https://www.acmicpc.net/problem/2309))

가능한 모든 조합 $$\binom n k = \binom 9 7$$을 모두 만들어보면 된다.

#### BOJ 1182 부분 집합의 합 ([문제 보기](https://www.acmicpc.net/problem/1182))

집합의 각 원소를 고르거나 고르지 않는 모든 경우 ( $$2^N$$)를 모두 만들어보면 된다.

#### BOJ 1759 암호 만들기 ([문제 보기](https://www.acmicpc.net/problem/1759))

모든 문자들을 사전순으로 정렬한 후  $$\binom C L$$의 경우를 모두 만들어보고, 최소 한 개 모음과 최소 두 개의 자음으로 구성되어 있는지 확인하면 된다.

#### BOJ 10974 모든 순열 ([문제 보기](https://www.acmicpc.net/problem/10974))

c++ STL std::next_permutation 함수를 사용하면 편한 문제이지만, 직접 재귀 함수로 모든 순열을 만들어보는 것도 좋다.

#### BOJ 10971 외판원 순회2 ([문제 보기](https://www.acmicpc.net/problem/10971))

모든 순열(도시들의 나열)을 만들어보면 되는 문제다.

#### BOJ 10448 유레카 이론 ([문제 보기](https://www.acmicpc.net/problem/10448))

세 개의 삼각수의 합이 될 수 있는 모든 경우를 미리 생성하여 그 정보를 저장해두면 된다. 

#### BOJ 1018 체스판 다시 칠하기 ([문제 보기](https://www.acmicpc.net/problem/1018))

보드의 각 위치에서 흰색으로 시작하는 경우와 검정색으로 시작하는 경우를 모두 따져보면 되는 문제이다.

<br>

## (2) 분할 정복 (Divide and Conquer)

### 2.1 분할 정복이란?

분할 정복은 문제를 재귀적으로 둘 이상의 보다 작은 부분 문제로 나눈 뒤, 부분 문제들의 답을 결합하여 문제를 해결하는 방식을 말한다. 분할 정복을 사용하는 알고리즘들은 보통 다음 세 가지 단계를 갖는다.

1. 분할 (divide): 문제를 더 작은 크기의 부분 문제로 나눈다.
2. 정복 (conquer): 부분 문제들은 재귀적으로 해결된다. 만약 부분 문제의 크기가 더 이상 나눌 수 없을 정도로 작거나 바로 해결 가능하다면 바로 해결한다.
3. 병합 (merge): 부분 문제들의 답을 원래 문제의 답으로 병합한다.

분할 정복은 큰 문제를 한 번에 해결하기 어려울 때, 문제 풀이를 단순화하기 위해 많이 사용된다. 더욱이 큰 문제를 비슷한 크기의 부분 문제로 자연스럽게 나눈 뒤, 부분 문제들의 답을 효율적으로 원래 문제의 답으로 결합할 수 있다면 문제를 빠르게 해결할 수 있다.

### 2.2 대표적인 분할 정복 알고리즘

분할 정복 전략을 취하는 많은 자료구조 및 알고리즘들이 존재한다. 예를 들면 다음과 같은 것들이다.

#### 자료 구조

- 이진 탐색 트리 (Binary Search Tree)
- 힙 (Heap)
- 구간 트리 (Segment Tree)
- 펜윅 트리 (Fenwick Tree = Binary Indexed Tree)

#### 알고리즘

- 이분 탐색 (Binary Search)
- 합병 정렬 (Merge sort)
- 퀵 정렬 (Quick Sort)
- 빠른 거듭 제곱 (Fast Pow)
- 스트라센의 행렬 곱셈 (Strassen's Matrix Multiplication)
- 가장 가까운 두 점 구하기 (Closest Pair of Points)
- 카라츠바의 빠른 곱셈 알고리즘 (Karatsuba algorithm for Fast Multiplication)
- 역전의 수 세기 (Count Inversions)
- 볼록 껍질 찾기 (Find Convex Hull)

### 2.3 예제

#### BOJ 1992 쿼드 트리 ([문제 보기](https://www.acmicpc.net/problem/1992))

주어진 공간이 모두 0이면 "0"을 찍고, 모두 1이면 "1"을 찍는다. 섞여 있으면 왼쪽 위, 왼쪽 아래, 오른쪽 위, 오른쪽 아래 부분으로 4분할해서 재귀적으로 해결한다. 

#### BOJ 11729 Z ([문제 보기](https://www.acmicpc.net/problem/11729))

숫자는 차례대로 왼쪽 위, 오른쪽 위, 왼쪽 아래, 오른쪽 아래순서이기 때문에 재귀적으로 4등분하다가 (r, c) 1칸에 도달하면 해당 칸에 수를 알 수 있다.

#### BOJ 6549 히스토그램에서 가장 큰 직사각형 ([문제 보기](https://www.acmicpc.net/problem/6549))

총 구간의 가운데를 기준으로 왼쪽, 오른쪽 구간을 나눌 수 있다. 답은 왼쪽 구간에 있거나 오른쪽 구간에 있거나 가운데를 포함하는 형태로 있을 수 있다. 왼쪽, 오른쪽 구간의 답은 1칸이 아닌 이상 재귀적으로 해결하면 된다. 가운데를 포함하는 최대 직사각형은 탐욕적으로 항상 왼쪽 직사각형, 오른쪽 직사각형 중 높이가 더 큰쪽으로 이어서 만들어가면 구할 수 있다.

구간 트리나 스택($$O(N)$$을 이용해서 풀 수도 있다.

#### BOJ 10827 a^b ([문제 보기](https://www.acmicpc.net/problem/10827))

정확한 실수 계산을 위해 큰 정수 배열을 만들고 큰 정수 배열에 대한 거듭 제곱 연산을 구현하면 된다. 거듭 제곱은 다음과 같은 공식으로 계산량을 줄일 수 있다.

$$ a^b =\begin{cases}a^{b/2} \times a^{b/2} & \text{ if } b: even \\ a^{b-1} \times a & \text{ if } b: odd \end{cases} $$ 

#### BOJ 1517 버블 소트 ([문제 보기](https://www.acmicpc.net/problem/1517))

역전의 수를 세는 문제다. 역전의 수는 합병 정렬(merge sort)을 하는 과정(병합 과정에서)에서 찾을 수 있다. 또는 펜윅 트리를 이용해도 풀 수 있다. (구간 트리는 메모리 초과)

<br>

## (3) 탐욕법 (Greedy)

### 3.1 탐욕법이란?

탐욕법은 최적화 문제를 풀 때, 최적해의 한 조각을 선택할 때마다 각 단계마다 가장 좋아보이는 선택을 취해나가는 방법이다. 탐욕법은 보통 다음 두 가지 상황에서 사용한다.

1. 특정 기준으로 가장 좋은 선택을 해나가는 것이 최적해를 보장하는 경우 (이 경우 증명이 필요하다)
2. 최적해를 찾는 방법이 너무 오래 걸릴경우 적당히 괜찮은 근사해를 찾으려고 하는 경우

### 3.2 예제

#### BOJ 11047 동전 0 ([문제 보기](https://www.acmicpc.net/problem/11047))

Ai (i >= 2)는 Aj (0<= j < i)의 배수이기 때문에 가치가 가장 큰 동전부터 최대한 많이 사용해나가면 최소의 동전으로 가치의 합 K를 만들 수 있다.

#### BOJ 1946 신입 사원 ([문제 보기](https://www.acmicpc.net/problem/1946))

모든 지원자의 성적이 공개되기 때문에 각 지원자는 자신의 채용 가능 여부를 명확하게 알 수 있다. 서류 또는 면접 성적으로 정렬하면 각 지원자의 채용 가능 여부를 $$O(N)$$에 확인할 수 있다.

#### BOJ 2437 저울 ([문제 보기](https://www.acmicpc.net/problem/2437))

현재 a까지 측정 가능하다고 가정하자. 여기에 무게 x인 저울이 추가된다면 x ~ a + x도 측정 가능하다. a까지 밖에 측정할 수 없다는 것은 가능한 모든 x에 대해 x > a+1이라는 것이다. 다시 말하면 가능한 x중 가장 작은 것인 x_min에 대해 x_min > a+1 이라는 말과 같다. 따라서 a=0인 순간부터 가장 작은 무게의 추 x_min을 추가해가면서 x_min > a+1 이 되는 순간을 찾으면 된다. 

#### BOJ 1700 멀티탭 스케줄링 ([문제 보기](https://www.acmicpc.net/problem/1700))

전기 용품 a를 사용할 차례라고 하자. 이때, 다음 순서를 따르면 된다.

1. 멀티탭에 a용품이 이미 꽂혀 있으면, 그대로 사용한다.
2. a가 꽂혀있는 칸은 없지만 멀티탭에 빈 칸이 있으면 전기 용품 a를 빈 칸에 꽂는다.
3. 빈 칸도 없으면 가장 오랜 기간 사용되지 않을 전기 용품을 멀티탭에서 뺀 후 꽂는다.

1, 2는 직관적으로 이해할 수 있지만 3의 경우 그럴듯해보이지만 명확한 증명이 어려울 수 있다. 이 문제는 사실 운영체제에서 가상 메모리를 효율적으로 관리하기 위해 최소로 페이지를 교체하는 방법을 찾는 문제와 동일한 문제다. 최적의 페이지 교체 알고리즘(optimal page replacement algorithm, min cache replacement algorithm)에서는 미래에 가장 오랫동안 사용되지 않을 페이지를 교체한다. 이 알고리즘의 정당성을 증명하는 것은 (읽어보지는 않았지만) 다소 복잡하다고 한다.

#### BOJ 1507 궁금한 민호 ([문제 보기](https://www.acmicpc.net/problem/1507))

모든 간선이 제거된 그래프에서 두 정점 사이의 최단 거리가 가장 짧은 두 점 a, b(주어진 배열에서 가장 작은 값)부터 연결해나가면서 플로이드 와샬 알고리즘으로 모든 쌍의 최단 거리를 구해준다. 이 작업을 그래프의 모든 정점간의 최단 거리가 주어진 배열과 같아질 때까지 반복한다. 매 단계마다 최단 거리가 d로 가장 짧은 두 점 a, b를 연결하려고 할 때, 다음 세 가지 상황이 존재한다.

1. 이전 단계에서 구한(플로이드로 인해) a, b 사이의 최단 거리가 d와 같다면 a, b 사이에 간선을 추가할 필요가 없다.
2. 이전 단계에서 구한 a, b 사이의 최단 거리가 d보다 크다면 a, b 사이에 간선을 추가해야 한다.
3. 이전 단계에서 구한 a, b 사이의 최단 거리가 d보다 작다면 모순이므로 주어진 정보가 잘못된 것이다.

#### BOJ 10610 30 ([문제 보기](https://www.acmicpc.net/problem/10610))

3의 배수는 각 자릿수의 합이 3으로 나누어 떨어진다. 따라서 N의 각 자릿의 합이 3으로 나누어 떨어지는지 확인하고, 나누어 떨어진다면 큰 수가 큰 자릿에 위치하도록 정렬하면 된다.

#### BOJ 1931 회의실배정 ([문제 보기](https://www.acmicpc.net/problem/1931))

가장 빨리 끝나는 회의부터 되는대로 선택해나가면 된다. 가장 빨리 끝나지 않는 회의부터 시작하는 최적의 배정 방법이 있다고 가정하면 이 배정 방법의 첫 시작 회의를 가장 빨리 끝나는 회의로 바꾸더라도 더 나빠지지 않으므로 가장 빨리 끝나는 회의부터 선택해나가는 것이 최적해를 가져다줌을 알 수 있다.

#### BOJ 1201 NMK ([문제 보기](https://www.acmicpc.net/problem/1201))

1부터 N까지 정렬된 배열이 있다고 하자. 이 배열을 M개로 분할한 후(M-1번 자른 후), 각각 분할된 배열의 순서를 뒤집으면 된다. 주의해서 구현할 점은 각 분할된 배열은 최소 1개의 원소를 가지도록 해야 되고, 분할된 배열 중 적어도 하나는 K개의 원소를 가지도록 해야 한다. 불가능한 경우는 N이 너무 적거나 (N < M+K-1) N이 너무 큰 경우 (N > M x K)이다.

<br>

## (4) 동적 계획법 (Dynamic Programming)

### 4.1 동적 계획법이란?

동적 계획법(dynamic programming)은 복잡한 문제를 보다 간단한 여러 개의 부분 문제로 나누어 푸는 방법으로 중요한 점은 한 번 계산한 부분 문제의 답을 저장해 두어 나중에 같은 부분 문제의 답을 이용할 때, 복잡한 연산 없이 바로 이용할 수 있도록 하는 것이 핵심이다. 주로 **중복되는 부분 문제(overlapping sub-problems)**와 **최적 부분 구조(optimal substructure)**를 가지고 있는 문제들을 풀때 사용된다. 보다 자세한 내용은 뒤에 후술한다.

동적 계획법을 이용한 알고리즘을 설계할 때 가장 중요한 것은 **현재 문제의 상태(state)**와 **현재 문제와 부분 문제간의 관계(relationship) 또는 전이(transitions)**를 파악하는 것이다. 문제들간의 관계 또는 전이를 정확하게 파악하면 알고리즘의 정당성을 얻을 수 있고, 동적 계획법 알고리즘의 시간복잡도는 상태의 수와 한 상태의 답을 결정짓기 위한 시간에 비례하므로 이를 잘 고려하여 문제간의 상태와 관계를 잘 파악하는 것이 중요하기 때문이다.

#### 중복되는 부분 문제 (Overlapping subproblems)

주어진 문제를 여러 개의 부분 문제로 나누어 풀 때, 같은 부분 문제의 답을 여러 번 계산하는 경우가 있을 수 있다. 이런 부분 문제들을 중복되는 부분 문제 (overlapping subproblems)라고 한다. 동적 계획법에서는 이런 중복되는 부분 문제들을 단 한번만 계산하여 알고리즘의 속도를 최적화한다. 예를 들어 이항 계수(binomial coefficient)를 구하는 문제를 보자. 이항 계수 $$\binom n r$$은 $$n$$개의 서로 다른 원소 중에서 $$r$$개의 원소를 순서없이 고르는 방법의 수로, 다음과 같은 점화식(파스칼의 법칙)이 성립한다. 

​							$$\binom n r = \binom {n-1} {r-1} + \binom {n-1} r$$

위 점화식을 토대로  $$\binom 4 2$$를 재귀적으로 구한다고 하면 아래 왼쪽 그림과 같이  $$\binom 2 1$$을 구하는 과정이 중복된다는 사실을 인지할 수 있다. 사람이 직접 계산할 때에는 문제가 중복됨을 바로 인지하여 한 번만 계산할 수도 있겠지만 컴퓨터는 그렇지 못한다. 아래 오른쪽 그림과 같이 중복되는 부분 문제를 단 한번만 계산하도록 하는 것이 동적 계획법의 핵심이다.

![overlapping-subproblems]({{ site.url }}/assets/overlapping-subproblems.png)

#### 최적 부분 구조 (Optimal substructure)

동적 계획법을 최적화 문제 풀이에 적용하려면, 주어진 문제에 중복되는 부분 문제 말고도 최적 부분 구조 (optimal substructure)라는 특성이 필요하다. 어떤 문제가 최적 부분 구조를 가진다는 것은 주어진 문제의 최적해를 그 문제의 부분 문제들의 최적해를 통해 얻을 수 있다는 것을 말한다. 예를 들어 아래 그림과 같이 서울에서 부산으로 가는 최단 경로 문제를 보자.

![optimal-substructure.png]({{ site.url }}/assets/optimal-substructure.png)

서울에서 부산으로 갈 때 반드시 대전을 지난다고 가정하면, 이 경로를 (서울 -> 대전)과 (대전 -> 부산)으로 나눌 수 있다. 그러면 두 구간의 최단 경로(각각 1km, 5km)를 찾아 둘을 이으면 항상 서울에서 부산으로 가는 최단 경로(6km)를 얻을 수 있게 된다. 이런 경우 전체 문제의 최적해(최단 거리)가 부분 문제들의 최적해를 통해 얻을 수 있으므로 최적 부분 구조를 가진다고 할 수 있다. 이러한 특성이 모든 최적화 문제에 성립하는 것은 아니다. 위의 문제에서 경로상에 통행료와 같은 다른 제약이 존재하고, 총 통행료 합이 얼마 이하여야만 한다는 특정 상황이 추가된다면 위에서 당연한 듯 보였던 최적 부분 구조는 성립하지 않게 된다. 따라서 동적 계획법을 최적화 문제 풀이에 적용하려면, 주어진 문제에 최적 부분 구조가 성립하는지를 잘 따져봐야 한다.

#### 경우의 수와 확률 (Counting and Probability)

동적 계획법은 초기에 최적화 문제를 풀기 위해 고안되었고 한다. 하지만 앞서 설명한 이항 계수를 구하는 문제와 같이 경우의 수를 세거나 확률을 계산하는 문제에서도 흔하게 사용된다. 경우의 수를 세는 문제들은 대게 재귀적인 특성을 가지고 있어 중복되는 부분 문제가 많고, 최적화 문제의 최적 부분 구조와 유사하게 어떤 문제의 경우의 수가 그 문제의 부분 문제들의 경우의 수들의 조합일 때가 많기 때문이다.

### 4.2 동적 계획법의 구현 (Top-Down vs Bottom-Up)

동적 계획법 알고리즘을 설계하였다면, 즉 문제의 상태와 문제들간의 관계 파악이 끝났다면 이를 코드로 구현해야 한다. 보통 두 가지 방식을 사용한다. 하나는 재귀 함수를 이용한 Top-Down 방식이고, 다른 하나는 반복문을 통해 DP 관계식 (점화식)을 채워나가는 Bottom-Up 방식이다. 두 방식 모두 각각의 장단점이 있으므로 문제의 특성을 고려하여 잘 선택하면 된다.

#### 재귀 함수를 이용한 구현 (Top-Down DP)

#### 반복문을 이용한 구현 (Bottom-Up DP)



